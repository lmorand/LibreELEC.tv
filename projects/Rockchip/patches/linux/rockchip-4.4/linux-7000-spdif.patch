diff --git a/sound/soc/rockchip/rockchip_spdif.c b/sound/soc/rockchip/rockchip_spdif.c
index fc0288e1f2..aa52c9fe8e 100644
--- a/sound/soc/rockchip/rockchip_spdif.c
+++ b/sound/soc/rockchip/rockchip_spdif.c
@@ -21,6 +21,7 @@
 #include <linux/regmap.h>
 #include <sound/pcm_params.h>
 #include <sound/dmaengine_pcm.h>
+#include <sound/asoundef.h>
 
 #include "rockchip_spdif.h"
 
@@ -111,6 +112,7 @@ static int rk_spdif_hw_params(struct snd_pcm_substream *substream,
 {
 	struct rk_spdif_dev *spdif = snd_soc_dai_get_drvdata(dai);
 	unsigned int val = SPDIF_CFGR_HALFWORD_ENABLE;
+	u32 reg_val;
 	int mclk;
 	int ret;
 
@@ -119,6 +121,19 @@ static int rk_spdif_hw_params(struct snd_pcm_substream *substream,
 	ret = clk_set_rate(spdif->mclk, mclk);
 	if (ret)
 		return ret;
+	
+	/* Add the PCM and raw data select interface */
+	switch (params_channels(params)) {
+	case 1: /* PCM mode */
+	case 2:
+		val |= 0;
+		break;
+	case 4: /* raw data mode */
+		val |= SPDIF_CFGR_PCMTYPE;
+		break;
+	default:
+		return -EINVAL;
+	}
 
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S16_LE:
@@ -134,11 +149,11 @@ static int rk_spdif_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
-	val |= SPDIF_CFGR_CLK_DIV(0);
-	ret = regmap_update_bits(spdif->regmap, SPDIF_CFGR,
-				 SPDIF_CFGR_CLK_DIV_MASK |
-				 SPDIF_CFGR_HALFWORD_ENABLE |
-				 SDPIF_CFGR_VDW_MASK, val);
+	reg_val = 0;
+	reg_val |= val;
+	reg_val |= SPDIF_CFGR_CLK_DIV(0);
+	reg_val |= SPDIF_CFGR_CSE;
+	ret = regmap_write(spdif->regmap, SPDIF_CFGR, reg_val);
 
 	return ret;
 }
@@ -188,11 +203,104 @@ static int rk_spdif_trigger(struct snd_pcm_substream *substream,
 	return ret;
 }
 
+static int rk_spdif_info(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+
+	return 0;
+}
+
+static int rk_spdif_get_status_mask(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
+{
+	u8 *status = ucontrol->value.iec958.status;
+
+	status[0] = 0xff;
+	status[1] = 0xff;
+	status[2] = 0xff;
+	status[3] = 0xff;
+	status[4] = 0xff;
+
+	return 0;
+}
+
+static int rk_spdif_get_status(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+	struct rk_spdif_dev *spdif = snd_soc_dai_get_drvdata(dai);
+	u8 *status = ucontrol->value.iec958.status;
+	unsigned int reg;
+
+	regmap_read(spdif->regmap, SPDIF_CHNSR0, &reg);
+
+	status[0] = reg & 0xff;
+	status[1] = (reg >> 8) & 0xff;
+	status[2] = (reg >> 16) & 0xff;
+	status[3] = (reg >> 24) & 0xff;
+
+	regmap_read(spdif->regmap, SPDIF_CHNSR1, &reg);
+
+	status[4] = reg & 0xff;
+
+	return 0;
+}
+
+static int rk_spdif_set_status(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+	struct rk_spdif_dev *spdif = snd_soc_dai_get_drvdata(dai);
+	u8 *status = ucontrol->value.iec958.status;
+	unsigned int reg;
+
+	reg = ((u32)status[3] << 24);
+	reg |= ((u32)status[2] << 16);
+	reg |= ((u32)status[1] << 8);
+	reg |= (u32)status[0];
+
+	regmap_write(spdif->regmap, SPDIF_CHNSR0, reg);
+
+	reg = status[4];
+	regmap_write(spdif->regmap, SPDIF_CHNSR1, reg);
+
+	reg = SPDIF_CFGR_CSE;
+	if (status[0] & IEC958_AES0_NONAUDIO)
+		reg |= SPDIF_CFGR_PCMTYPE;
+
+	regmap_update_bits(spdif->regmap, SPDIF_CFGR,
+			   SPDIF_CFGR_CSE |
+			   SPDIF_CFGR_PCMTYPE, reg);
+
+	return 0;
+}
+
+static struct snd_kcontrol_new rk_spdif_controls[] = {
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ,
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, MASK),
+		.info = rk_spdif_info,
+		.get = rk_spdif_get_status_mask
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
+		.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
+		.info = rk_spdif_info,
+		.get = rk_spdif_get_status,
+		.put = rk_spdif_set_status
+	}
+};
+
 static int rk_spdif_dai_probe(struct snd_soc_dai *dai)
 {
 	struct rk_spdif_dev *spdif = snd_soc_dai_get_drvdata(dai);
 
 	dai->playback_dma_data = &spdif->playback_dma_data;
+	snd_soc_add_dai_controls(dai, rk_spdif_controls,
+				 ARRAY_SIZE(rk_spdif_controls));
 
 	return 0;
 }
diff --git a/sound/soc/rockchip/rockchip_spdif.h b/sound/soc/rockchip/rockchip_spdif.h
index 3ef12770ae..1652d212b3 100644
--- a/sound/soc/rockchip/rockchip_spdif.h
+++ b/sound/soc/rockchip/rockchip_spdif.h
@@ -20,6 +20,9 @@
 #define SPDIF_CFGR_CLK_DIV_MASK		(0xff << SPDIF_CFGR_CLK_DIV_SHIFT)
 #define SPDIF_CFGR_CLK_DIV(x)		(x << SPDIF_CFGR_CLK_DIV_SHIFT)
 
+#define SPDIF_CFGR_PCMTYPE BIT(8)
+#define SPDIF_CFGR_CSE BIT(6)
+
 #define SPDIF_CFGR_HALFWORD_SHIFT	2
 #define SPDIF_CFGR_HALFWORD_DISABLE	(0 << SPDIF_CFGR_HALFWORD_SHIFT)
 #define SPDIF_CFGR_HALFWORD_ENABLE	(1 << SPDIF_CFGR_HALFWORD_SHIFT)
@@ -59,5 +62,7 @@
 #define SPDIF_INTSR	(0x0010)
 #define SPDIF_XFER	(0x0018)
 #define SPDIF_SMPDR	(0x0020)
+#define SPDIF_CHNSR0 (0x00c0)
+#define SPDIF_CHNSR1 (0x00e0)
 
 #endif /* _ROCKCHIP_SPDIF_H */
