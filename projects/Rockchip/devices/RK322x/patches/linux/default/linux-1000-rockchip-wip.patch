From 4707a7fe2103b7600b2ca6097ce9d12bda37d4cf Mon Sep 17 00:00:00 2001
From: Finley Xiao <finley.xiao@rock-chips.com>
Date: Thu, 22 Jun 2017 20:22:25 +0800
Subject: [PATCH] clk: rockchip: rk3228: fix some PLL_NUX_CLKs' gates

Some PLL_NUX_CLKs' gates is actually behind muxs according to latest TRM,
so move the gates to composite clocks and amend their parent clocks.

Change-Id: Ib6043caa61e9df0473f2d0bdc756850968bb2a55
Signed-off-by: Finley Xiao <finley.xiao@rock-chips.com>
---
 drivers/clk/rockchip/clk-rk3228.c | 49 ++++++++++---------------------
 1 file changed, 15 insertions(+), 34 deletions(-)

diff --git a/drivers/clk/rockchip/clk-rk3228.c b/drivers/clk/rockchip/clk-rk3228.c
index c1ef00247e26..6da33172c6ba 100644
--- a/drivers/clk/rockchip/clk-rk3228.c
+++ b/drivers/clk/rockchip/clk-rk3228.c
@@ -134,24 +134,22 @@ static const struct rockchip_cpuclk_reg_data rk3228_cpuclk_data = {
 
 PNAME(mux_pll_p)		= { "clk_24m", "xin24m" };
 
-PNAME(mux_ddrphy_p)		= { "dpll_ddr", "gpll_ddr", "apll_ddr" };
+PNAME(mux_ddrphy_p)		= { "dpll", "gpll", "apll" };
 PNAME(mux_armclk_p)		= { "apll_core", "gpll_core", "dpll_core" };
 PNAME(mux_usb480m_phy_p)	= { "usb480m_phy0", "usb480m_phy1" };
 PNAME(mux_usb480m_p)		= { "usb480m_phy", "xin24m" };
 PNAME(mux_hdmiphy_p)		= { "hdmiphy_phy", "xin24m" };
-PNAME(mux_aclk_cpu_src_p)	= { "cpll_aclk_cpu", "gpll_aclk_cpu", "hdmiphy_aclk_cpu" };
 
 PNAME(mux_pll_src_4plls_p)	= { "cpll", "gpll", "hdmiphy", "usb480m" };
 PNAME(mux_pll_src_3plls_p)	= { "cpll", "gpll", "hdmiphy" };
 PNAME(mux_pll_src_2plls_p)	= { "cpll", "gpll" };
 PNAME(mux_sclk_hdmi_cec_p)	= { "cpll", "gpll", "xin24m" };
-PNAME(mux_aclk_peri_src_p)	= { "cpll_peri", "gpll_peri", "hdmiphy_peri" };
 PNAME(mux_mmc_src_p)		= { "cpll", "gpll", "xin24m", "usb480m" };
 PNAME(mux_pll_src_cpll_gpll_usb480m_p)	= { "cpll", "gpll", "usb480m" };
 
 PNAME(mux_sclk_rga_p)		= { "gpll", "cpll", "sclk_rga_src" };
 
-PNAME(mux_sclk_vop_src_p)	= { "gpll_vop", "cpll_vop" };
+PNAME(mux_sclk_vop_src_p)	= { "gpll", "cpll" };
 PNAME(mux_dclk_vop_p)		= { "hdmiphy", "sclk_vop_pre" };
 
 PNAME(mux_i2s0_p)		= { "i2s0_src", "i2s0_frac", "ext_i2s", "xin12m" };
@@ -220,27 +218,23 @@ static struct rockchip_clk_branch rk3228_clk_branches[] __initdata = {
 			RK2928_CLKSEL_CON(4), 8, 5, DFLAGS),
 
 	/* PD_DDR */
-	GATE(0, "apll_ddr", "apll", CLK_IGNORE_UNUSED,
+	COMPOSITE(0, "clk_ddrphy_src", mux_ddrphy_p, CLK_IGNORE_UNUSED,
+			RK2928_CLKSEL_CON(26), 8, 2, MFLAGS, 0, 2, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
 			RK2928_CLKGATE_CON(0), 2, GFLAGS),
-	GATE(0, "dpll_ddr", "dpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 2, GFLAGS),
-	GATE(0, "gpll_ddr", "gpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 2, GFLAGS),
-	COMPOSITE(0, "ddrphy4x", mux_ddrphy_p, CLK_IGNORE_UNUSED,
-			RK2928_CLKSEL_CON(26), 8, 2, MFLAGS, 0, 3, DFLAGS | CLK_DIVIDER_POWER_OF_TWO,
+	GATE(0, "ddrphy4x", "clk_ddrphy_src", CLK_IGNORE_UNUSED,
 			RK2928_CLKGATE_CON(7), 1, GFLAGS),
-	GATE(0, "ddrc", "ddrphy_pre", CLK_IGNORE_UNUSED,
+	FACTOR_GATE(0, "ddrc", "clk_ddrphy_src", CLK_IGNORE_UNUSED, 1, 4,
 			RK2928_CLKGATE_CON(8), 5, GFLAGS),
-	FACTOR_GATE(0, "ddrphy", "ddrphy4x", CLK_IGNORE_UNUSED, 1, 4,
+	FACTOR_GATE(0, "ddrphy", "clk_ddrphy_src", CLK_IGNORE_UNUSED, 1, 4,
 			RK2928_CLKGATE_CON(7), 0, GFLAGS),
 
 	/* PD_CORE */
-	GATE(0, "dpll_core", "dpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 6, GFLAGS),
 	GATE(0, "apll_core", "apll", CLK_IGNORE_UNUSED,
 			RK2928_CLKGATE_CON(0), 6, GFLAGS),
 	GATE(0, "gpll_core", "gpll", CLK_IGNORE_UNUSED,
 			RK2928_CLKGATE_CON(0), 6, GFLAGS),
+	GATE(0, "dpll_core", "dpll", CLK_IGNORE_UNUSED,
+			RK2928_CLKGATE_CON(0), 6, GFLAGS),
 	COMPOSITE_NOMUX(0, "pclk_dbg", "armclk", CLK_IGNORE_UNUSED,
 			RK2928_CLKSEL_CON(1), 0, 4, DFLAGS | CLK_DIVIDER_READ_ONLY,
 			RK2928_CLKGATE_CON(4), 1, GFLAGS),
@@ -257,14 +251,9 @@ static struct rockchip_clk_branch rk3228_clk_branches[] __initdata = {
 			RK2928_MISC_CON, 15, 1, MFLAGS),
 
 	/* PD_BUS */
-	GATE(0, "hdmiphy_aclk_cpu", "hdmiphy", CLK_IGNORE_UNUSED,
+	COMPOSITE(0, "aclk_cpu_src", mux_pll_src_3plls_p, 0,
+			RK2928_CLKSEL_CON(0), 13, 2, MFLAGS, 8, 5, DFLAGS,
 			RK2928_CLKGATE_CON(0), 1, GFLAGS),
-	GATE(0, "gpll_aclk_cpu", "gpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 1, GFLAGS),
-	GATE(0, "cpll_aclk_cpu", "cpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(0), 1, GFLAGS),
-	COMPOSITE_NOGATE(0, "aclk_cpu_src", mux_aclk_cpu_src_p, 0,
-			RK2928_CLKSEL_CON(0), 13, 2, MFLAGS, 8, 5, DFLAGS),
 	GATE(ACLK_CPU, "aclk_cpu", "aclk_cpu_src", 0,
 			RK2928_CLKGATE_CON(6), 0, GFLAGS),
 	COMPOSITE_NOMUX(HCLK_CPU, "hclk_cpu", "aclk_cpu_src", 0,
@@ -337,14 +326,9 @@ static struct rockchip_clk_branch rk3228_clk_branches[] __initdata = {
 			RK2928_CLKGATE_CON(3), 8, GFLAGS),
 
 	/* PD_PERI */
-	GATE(0, "cpll_peri", "cpll", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(2), 0, GFLAGS),
-	GATE(0, "gpll_peri", "gpll", CLK_IGNORE_UNUSED,
+	COMPOSITE(0, "aclk_peri_src", mux_pll_src_3plls_p, 0,
+			RK2928_CLKSEL_CON(10), 10, 2, MFLAGS, 0, 5, DFLAGS,
 			RK2928_CLKGATE_CON(2), 0, GFLAGS),
-	GATE(0, "hdmiphy_peri", "hdmiphy", CLK_IGNORE_UNUSED,
-			RK2928_CLKGATE_CON(2), 0, GFLAGS),
-	COMPOSITE_NOGATE(0, "aclk_peri_src", mux_aclk_peri_src_p, 0,
-			RK2928_CLKSEL_CON(10), 10, 2, MFLAGS, 0, 5, DFLAGS),
 	COMPOSITE_NOMUX(PCLK_PERI, "pclk_peri", "aclk_peri_src", 0,
 			RK2928_CLKSEL_CON(10), 12, 3, DFLAGS,
 			RK2928_CLKGATE_CON(5), 2, GFLAGS),
@@ -402,12 +386,9 @@ static struct rockchip_clk_branch rk3228_clk_branches[] __initdata = {
 	 * Clock-Architecture Diagram 2
 	 */
 
-	GATE(0, "gpll_vop", "gpll", 0,
-			RK2928_CLKGATE_CON(3), 1, GFLAGS),
-	GATE(0, "cpll_vop", "cpll", 0,
+	COMPOSITE_NODIV(0, "sclk_vop_src", mux_sclk_vop_src_p, 0,
+			RK2928_CLKSEL_CON(27), 0, 1, MFLAGS,
 			RK2928_CLKGATE_CON(3), 1, GFLAGS),
-	MUX(0, "sclk_vop_src", mux_sclk_vop_src_p, 0,
-			RK2928_CLKSEL_CON(27), 0, 1, MFLAGS),
 	DIV(DCLK_HDMI_PHY, "dclk_hdmiphy", "sclk_vop_src", 0,
 			RK2928_CLKSEL_CON(29), 0, 3, DFLAGS),
 	DIV(0, "sclk_vop_pre", "sclk_vop_src", 0,

From d575c876e7f19e1699471d88edfe8d1874f6dd21 Mon Sep 17 00:00:00 2001
From: Finley Xiao <finley.xiao@rock-chips.com>
Date: Sun, 18 Mar 2018 21:41:43 +0800
Subject: [PATCH] clk: rockchip: rk3228: Fix sclk_wifi div_width

Change-Id: I8e216249fbd588ce55660eba9911fc59aedc920d
Signed-off-by: Finley Xiao <finley.xiao@rock-chips.com>
---
 drivers/clk/rockchip/clk-rk3228.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/clk/rockchip/clk-rk3228.c b/drivers/clk/rockchip/clk-rk3228.c
index 6da33172c6ba..d59e619425b6 100644
--- a/drivers/clk/rockchip/clk-rk3228.c
+++ b/drivers/clk/rockchip/clk-rk3228.c
@@ -363,7 +363,7 @@ static struct rockchip_clk_branch rk3228_clk_branches[] __initdata = {
 			RK2928_CLKGATE_CON(10), 12, GFLAGS),
 
 	COMPOSITE(SCLK_WIFI, "sclk_wifi", mux_pll_src_cpll_gpll_usb480m_p, 0,
-			RK2928_CLKSEL_CON(23), 5, 2, MFLAGS, 0, 6, DFLAGS,
+			RK2928_CLKSEL_CON(23), 5, 2, MFLAGS, 0, 5, DFLAGS,
 			RK2928_CLKGATE_CON(2), 15, GFLAGS),
 
 	COMPOSITE(SCLK_SDMMC, "sclk_sdmmc", mux_mmc_src_p, 0,

From 13db1588f0807f2d0569a45b93d6597280e105f6 Mon Sep 17 00:00:00 2001
From: Chen Lei <lei.chen@rock-chips.com>
Date: Tue, 25 Dec 2018 18:29:04 +0800
Subject: [PATCH] clk: rockchip: rk322x: fix wrong mmc phase shift for rk3228

mmc sample shift should be 1 for rk3228, or it will fail
if we enable mmc tuning for rk3228.

Change-Id: I301c2a7d33de8d519d7c288aef03a82531016373
Signed-off-by: Chen Lei <lei.chen@rock-chips.com>
---
 drivers/clk/rockchip/clk-rk3228.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/drivers/clk/rockchip/clk-rk3228.c b/drivers/clk/rockchip/clk-rk3228.c
index d59e619425b6..9c5ad7c71143 100644
--- a/drivers/clk/rockchip/clk-rk3228.c
+++ b/drivers/clk/rockchip/clk-rk3228.c
@@ -620,13 +620,13 @@ static struct rockchip_clk_branch rk3228_clk_branches[] __initdata = {
 
 	/* PD_MMC */
 	MMC(SCLK_SDMMC_DRV,    "sdmmc_drv",    "sclk_sdmmc", RK3228_SDMMC_CON0, 1),
-	MMC(SCLK_SDMMC_SAMPLE, "sdmmc_sample", "sclk_sdmmc", RK3228_SDMMC_CON1, 0),
+	MMC(SCLK_SDMMC_SAMPLE, "sdmmc_sample", "sclk_sdmmc", RK3228_SDMMC_CON1, 1),
 
 	MMC(SCLK_SDIO_DRV,     "sdio_drv",     "sclk_sdio",  RK3228_SDIO_CON0,  1),
-	MMC(SCLK_SDIO_SAMPLE,  "sdio_sample",  "sclk_sdio",  RK3228_SDIO_CON1,  0),
+	MMC(SCLK_SDIO_SAMPLE,  "sdio_sample",  "sclk_sdio",  RK3228_SDIO_CON1,  1),
 
 	MMC(SCLK_EMMC_DRV,     "emmc_drv",     "sclk_emmc",  RK3228_EMMC_CON0,  1),
-	MMC(SCLK_EMMC_SAMPLE,  "emmc_sample",  "sclk_emmc",  RK3228_EMMC_CON1,  0),
+	MMC(SCLK_EMMC_SAMPLE,  "emmc_sample",  "sclk_emmc",  RK3228_EMMC_CON1,  1),
 };
 
 static const char *const rk3228_critical_clocks[] __initconst = {

From 8b9b8802556c4f7ce09699a4a85e19143de43c44 Mon Sep 17 00:00:00 2001
From: Alex Bee <knaerzche@gmail.com>
Date: Mon, 14 Dec 2020 21:05:15 +0100
Subject: [PATCH] clk: rockchip: add *_vio_h2p to RK3228's critical clocks

These are required in order to read the HDMI edid and must not
get disabled in order to successfully do so.

Signed-off-by: Alex Bee <knaerzche@gmail.com>
---
 drivers/clk/rockchip/clk-rk3228.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/clk/rockchip/clk-rk3228.c b/drivers/clk/rockchip/clk-rk3228.c
index 9c5ad7c71143..4b2aca6b1f11 100644
--- a/drivers/clk/rockchip/clk-rk3228.c
+++ b/drivers/clk/rockchip/clk-rk3228.c
@@ -641,6 +641,7 @@ static const char *const rk3228_critical_clocks[] __initconst = {
 	"aclk_vop_noc",
 	"aclk_hdcp_noc",
 	"hclk_vio_ahb_arbi",
+	"hclk_vio_h2p",
 	"hclk_vio_noc",
 	"hclk_vop_noc",
 	"hclk_host0_arb",
@@ -658,6 +659,7 @@ static const char *const rk3228_critical_clocks[] __initconst = {
 	"pclk_ddrphy",
 	"pclk_acodecphy",
 	"pclk_phy_noc",
+	"pclk_vio_h2p",
 	"aclk_vpu_noc",
 	"aclk_rkvdec_noc",
 	"hclk_vpu_noc",

From 3fc147d54b06e6451775465e35de17a6126377c2 Mon Sep 17 00:00:00 2001
From: Alex Bee <knaerzche@gmail.com>
Date: Sun, 16 Aug 2020 17:07:35 +0200
Subject: [PATCH] clk: rockchip add aclk_rkvdec and hclk_rkvdec to RK3228
 critical clocks

To be prevented from being disabled at any time add aclk_rkvdec and hclk_rkvdec
to RK3228 critical clocks
---
 drivers/clk/rockchip/clk-rk3228.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/clk/rockchip/clk-rk3228.c b/drivers/clk/rockchip/clk-rk3228.c
index 4b2aca6b1f11..2ac006e99c03 100644
--- a/drivers/clk/rockchip/clk-rk3228.c
+++ b/drivers/clk/rockchip/clk-rk3228.c
@@ -662,8 +662,10 @@ static const char *const rk3228_critical_clocks[] __initconst = {
 	"pclk_vio_h2p",
 	"aclk_vpu_noc",
 	"aclk_rkvdec_noc",
+	"aclk_rkvdec",
 	"hclk_vpu_noc",
 	"hclk_rkvdec_noc",
+	"hclk_rkvdec",
 };
 
 static void __init rk3228_clk_init(struct device_node *np)

From 8384abedb84b4f9c8648a92108de94b4b8d188a6 Mon Sep 17 00:00:00 2001
From: Alex Bee <knaerzche@gmail.com>
Date: Fri, 24 Apr 2020 11:42:58 +0200
Subject: [PATCH] soc: rockchip: Support powerdomains which don't need /
 support to be switched on / off

Taken from https://github.com/rockchip-linux/kernel/commit/5be2cb19cf8e678655b59ec70c6a5f66f08d9418
---
 drivers/soc/rockchip/pm_domains.c | 23 +++++++++++++++++++++++
 1 file changed, 23 insertions(+)

diff --git a/drivers/soc/rockchip/pm_domains.c b/drivers/soc/rockchip/pm_domains.c
index 54eb6cfc5d5b..c6b33f7c43df 100644
--- a/drivers/soc/rockchip/pm_domains.c
+++ b/drivers/soc/rockchip/pm_domains.c
@@ -71,6 +71,7 @@ struct rockchip_pm_domain {
 	struct regmap **qos_regmap;
 	u32 *qos_save_regs[MAX_QOS_REGS_NUM];
 	int num_clks;
+	bool is_ignore_pwr;
 	struct clk_bulk_data *clks;
 };
 
@@ -330,6 +331,9 @@ static int rockchip_pd_power_on(struct generic_pm_domain *domain)
 {
 	struct rockchip_pm_domain *pd = to_rockchip_pd(domain);
 
+	if (pd->is_ignore_pwr)
+		return 0;
+
 	return rockchip_pd_power(pd, true);
 }
 
@@ -337,6 +341,9 @@ static int rockchip_pd_power_off(struct generic_pm_domain *domain)
 {
 	struct rockchip_pm_domain *pd = to_rockchip_pd(domain);
 
+	if (pd->is_ignore_pwr)
+		return 0;
+
 	return rockchip_pd_power(pd, false);
 }
 
@@ -416,6 +423,9 @@ static int rockchip_pm_add_one_domain(struct rockchip_pmu *pmu,
 	pd->info = pd_info;
 	pd->pmu = pmu;
 
+	if (!pd_info->pwr_mask)
+		pd->is_ignore_pwr = true;
+
 	pd->num_clks = of_clk_get_parent_count(node);
 	if (pd->num_clks > 0) {
 		pd->clks = devm_kcalloc(pmu->dev, pd->num_clks,
@@ -566,6 +576,7 @@ static int rockchip_pm_add_subdomain(struct rockchip_pmu *pmu,
 {
 	struct device_node *np;
 	struct generic_pm_domain *child_domain, *parent_domain;
+	struct rockchip_pm_domain *child_pd, *parent_pd;
 	int error;
 
 	for_each_child_of_node(parent, np) {
@@ -606,6 +617,18 @@ static int rockchip_pm_add_subdomain(struct rockchip_pmu *pmu,
 				parent_domain->name, child_domain->name);
 		}
 
+		/*
+		 * If child_pd doesn't do idle request or power on/off,
+		 * parent_pd may fail to do power on/off, so if parent_pd
+		 * need to power on/off, child_pd can't ignore to do idle
+		 * request and power on/off.
+		 */
+		child_pd = to_rockchip_pd(child_domain);
+		parent_pd = to_rockchip_pd(parent_domain);
+		if (!parent_pd->is_ignore_pwr)
+			child_pd->is_ignore_pwr = false;
+
+
 		rockchip_pm_add_subdomain(pmu, np);
 	}
 

From 14c607b588c49705ac0486d63590876089b41a20 Mon Sep 17 00:00:00 2001
From: Alex Bee <knaerzche@gmail.com>
Date: Fri, 24 Apr 2020 09:08:44 +0200
Subject: [PATCH] phy: rockchip: hdmi: readout hdmi phy flag for RK3228 HDMI
 phys

Some RK3228 HDMI phys only get a stable pll on frequencies higher 33,75 MHz.
This is defined in a flag in efuse of those devices.
---
 arch/arm/boot/dts/rk322x.dtsi                 |  6 +++
 drivers/phy/rockchip/phy-rockchip-inno-hdmi.c | 38 ++++++++++++++++++-
 2 files changed, 42 insertions(+), 2 deletions(-)

diff --git a/arch/arm/boot/dts/rk322x.dtsi b/arch/arm/boot/dts/rk322x.dtsi
index 48e6e8d44a1a..a5f1d1a004d4 100644
--- a/arch/arm/boot/dts/rk322x.dtsi
+++ b/arch/arm/boot/dts/rk322x.dtsi
@@ -317,6 +317,10 @@ efuse_id: id@7 {
 		cpu_leakage: cpu_leakage@17 {
 			reg = <0x17 0x1>;
 		};
+		hdmi_phy_flag: hdmi-phy-flag@1d {
+			reg = <0x1d 0x1>;
+			bits = <1 1>;
+		};
 	};
 
 	i2c0: i2c@11050000 {
@@ -536,6 +540,8 @@ hdmi_phy: hdmi-phy@12030000 {
 		clock-names = "sysclk", "refoclk", "refpclk";
 		#clock-cells = <0>;
 		clock-output-names = "hdmiphy_phy";
+		nvmem-cells = <&hdmi_phy_flag>;
+		nvmem-cell-names = "hdmi-phy-flag";
 		#phy-cells = <0>;
 		status = "disabled";
 	};
diff --git a/drivers/phy/rockchip/phy-rockchip-inno-hdmi.c b/drivers/phy/rockchip/phy-rockchip-inno-hdmi.c
index bb8bdf5e3301..0c7a97352714 100644
--- a/drivers/phy/rockchip/phy-rockchip-inno-hdmi.c
+++ b/drivers/phy/rockchip/phy-rockchip-inno-hdmi.c
@@ -237,6 +237,9 @@ struct inno_hdmi_phy {
 	struct clk *refoclk;
 	struct clk *refpclk;
 
+	/* phy_flag flag */
+	bool phy_flag;
+
 	/* platform data */
 	const struct inno_hdmi_phy_drv_data *plat_data;
 	int chip_version;
@@ -347,6 +350,7 @@ static const struct pre_pll_config pre_pll_cfg_table[] = {
 static const struct post_pll_config post_pll_cfg_table[] = {
 	{33750000,  1, 40, 8, 1},
 	{33750000,  1, 80, 8, 2},
+	{33750000,  1, 10, 2, 4},
 	{74250000,  1, 40, 8, 1},
 	{74250000, 18, 80, 8, 2},
 	{148500000, 2, 40, 4, 3},
@@ -497,8 +501,11 @@ static int inno_hdmi_phy_power_on(struct phy *phy)
 		return -EINVAL;
 
 	for (; cfg->tmdsclock != 0; cfg++)
-		if (tmdsclock <= cfg->tmdsclock &&
-		    cfg->version & inno->chip_version)
+		if (((!inno->phy_flag || tmdsclock > 33750000)
+		     && tmdsclock <= cfg->tmdsclock
+		     && cfg->version & inno->chip_version) ||
+		    (inno->phy_flag && tmdsclock <= 33750000
+		     && cfg->version & 4))
 			break;
 
 	for (; phy_cfg->tmdsclock != 0; phy_cfg++)
@@ -909,6 +916,10 @@ static int inno_hdmi_phy_clk_register(struct inno_hdmi_phy *inno)
 
 static int inno_hdmi_phy_rk3228_init(struct inno_hdmi_phy *inno)
 {
+	struct nvmem_cell *cell;
+	unsigned char *efuse_buf;
+	size_t len;
+
 	/*
 	 * Use phy internal register control
 	 * rxsense/poweron/pllpd/pdataen signal.
@@ -923,7 +934,28 @@ static int inno_hdmi_phy_rk3228_init(struct inno_hdmi_phy *inno)
 	inno_update_bits(inno, 0xaa, RK3228_POST_PLL_CTRL_MANUAL,
 			 RK3228_POST_PLL_CTRL_MANUAL);
 
+
 	inno->chip_version = 1;
+	inno->phy_flag = false;
+
+	cell = nvmem_cell_get(inno->dev, "hdmi-phy-flag");
+	if (IS_ERR(cell)) {
+		if (PTR_ERR(cell) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+
+		return 0;
+	}
+
+	efuse_buf = nvmem_cell_read(cell, &len);
+	nvmem_cell_put(cell);
+
+	if (IS_ERR(efuse_buf))
+		return 0;
+	if (len == 1)
+		inno->phy_flag = (efuse_buf[0] & BIT(1)) ? true : false;
+	kfree(efuse_buf);
+
+	dev_info(inno->dev, "phy_flag is: %d\n", inno->phy_flag);
 
 	return 0;
 }
@@ -1023,6 +1055,8 @@ static int inno_hdmi_phy_rk3328_init(struct inno_hdmi_phy *inno)
 
 	/* try to read the chip-version */
 	inno->chip_version = 1;
+	inno->phy_flag = false;
+
 	cell = nvmem_cell_get(inno->dev, "cpu-version");
 	if (IS_ERR(cell)) {
 		if (PTR_ERR(cell) == -EPROBE_DEFER)

From 01d16d33ee32f2e2de85cbc8a0a399527c2121ad Mon Sep 17 00:00:00 2001
From: Alex Bee <knaerzche@gmail.com>
Date: Tue, 26 May 2020 14:41:39 +0200
Subject: [PATCH] usb: dwc2: QUIRKS: rockchip host only controller needs longer
 msleep to initialize

---
 drivers/usb/dwc2/core.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/usb/dwc2/core.c b/drivers/usb/dwc2/core.c
index fec17a2d2447..eb55c64f63be 100644
--- a/drivers/usb/dwc2/core.c
+++ b/drivers/usb/dwc2/core.c
@@ -663,7 +663,7 @@ void dwc2_force_dr_mode(struct dwc2_hsotg *hsotg)
 		 * platforms on their host-only dwc2.
 		 */
 		if (!dwc2_hw_is_otg(hsotg))
-			msleep(50);
+			msleep(200);
 
 		break;
 	case USB_DR_MODE_PERIPHERAL:

From ddbce05adbd8870b928b73d2f00c44f1044c1b25 Mon Sep 17 00:00:00 2001
From: Alex Bee <knaerzche@gmail.com>
Date: Sun, 16 Aug 2020 17:35:43 +0200
Subject: [PATCH] nvmem: rockchip-efuse: fix RK3066/RK3188 efuse read

In order to read from RK3066/RK3188 efuse, the logic is slightly different from
whats done currently for RK3288 and also used for this SoC.
Logic, register mask and udelays have been taken from vendor kernel.
---
 drivers/nvmem/rockchip-efuse.c | 51 ++++++++++++++++++++++++++++++++--
 1 file changed, 49 insertions(+), 2 deletions(-)

diff --git a/drivers/nvmem/rockchip-efuse.c b/drivers/nvmem/rockchip-efuse.c
index e4579de5d014..424da17d6f84 100644
--- a/drivers/nvmem/rockchip-efuse.c
+++ b/drivers/nvmem/rockchip-efuse.c
@@ -17,6 +17,8 @@
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
 
+#define RK3066_A_MASK		0xff
+
 #define RK3288_A_SHIFT		6
 #define RK3288_A_MASK		0x3ff
 #define RK3288_PGENB		BIT(3)
@@ -52,6 +54,51 @@ struct rockchip_efuse_chip {
 	struct clk *clk;
 };
 
+static int rockchip_rk3066_efuse_read(void *context, unsigned int offset,
+				      void *val, size_t bytes)
+{
+	struct rockchip_efuse_chip *efuse = context;
+	u8 *buf = val;
+	int ret;
+
+	ret = clk_prepare_enable(efuse->clk);
+	if (ret < 0) {
+		dev_err(efuse->dev, "failed to prepare/enable efuse clk\n");
+		return ret;
+	}
+
+	writel(RK3288_CSB, efuse->base + REG_EFUSE_CTRL);
+	writel(RK3288_LOAD | RK3288_PGENB, efuse->base + REG_EFUSE_CTRL);
+	udelay(2);
+
+	while (bytes--) {
+		writel(readl(efuse->base + REG_EFUSE_CTRL) &
+			     (~(RK3066_A_MASK << RK3288_A_SHIFT)),
+			     efuse->base + REG_EFUSE_CTRL);
+		writel(readl(efuse->base + REG_EFUSE_CTRL) |
+			     ((offset++ & RK3066_A_MASK) << RK3288_A_SHIFT),
+			     efuse->base + REG_EFUSE_CTRL);
+		udelay(2);
+		writel(readl(efuse->base + REG_EFUSE_CTRL) |
+			     RK3288_STROBE, efuse->base + REG_EFUSE_CTRL);
+		udelay(2);
+
+		*buf++ = readl(efuse->base + REG_EFUSE_DOUT);
+		writel(readl(efuse->base + REG_EFUSE_CTRL) &
+		       (~RK3288_STROBE), efuse->base + REG_EFUSE_CTRL);
+		udelay(2);
+	}
+
+	udelay(2);
+	/* Switch to standby mode */
+	writel(RK3288_PGENB | RK3288_CSB, efuse->base + REG_EFUSE_CTRL);
+	udelay(1);
+
+	clk_disable_unprepare(efuse->clk);
+
+	return 0;
+}
+
 static int rockchip_rk3288_efuse_read(void *context, unsigned int offset,
 				      void *val, size_t bytes)
 {
@@ -218,11 +265,11 @@ static const struct of_device_id rockchip_efuse_match[] = {
 	},
 	{
 		.compatible = "rockchip,rk3066a-efuse",
-		.data = (void *)&rockchip_rk3288_efuse_read,
+		.data = (void *)&rockchip_rk3066_efuse_read,
 	},
 	{
 		.compatible = "rockchip,rk3188-efuse",
-		.data = (void *)&rockchip_rk3288_efuse_read,
+		.data = (void *)&rockchip_rk3066_efuse_read,
 	},
 	{
 		.compatible = "rockchip,rk3228-efuse",

From 37dda5c7dbdd36fbb92abb4a4b2505150714361b Mon Sep 17 00:00:00 2001
From: Alex Bee <knaerzche@gmail.com>
Date: Sun, 16 Aug 2020 17:43:08 +0200
Subject: [PATCH] ARM: dts: rockchip: fix RK3066/RK3188 efuse register width

As with most Rockchip SoCs the RK3066/RK3188 non-secure efuse contains 32 bytes of data.
This adapts the register width, so that we don't get repeated data when reading
out the values from it.
---
 arch/arm/boot/dts/rk3066a.dtsi | 2 +-
 arch/arm/boot/dts/rk3188.dtsi  | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/arm/boot/dts/rk3066a.dtsi b/arch/arm/boot/dts/rk3066a.dtsi
index f91ce30549c2..6feeaf90a40c 100644
--- a/arch/arm/boot/dts/rk3066a.dtsi
+++ b/arch/arm/boot/dts/rk3066a.dtsi
@@ -244,7 +244,7 @@ timer@2000e000 {
 
 	efuse: efuse@20010000 {
 		compatible = "rockchip,rk3066a-efuse";
-		reg = <0x20010000 0x4000>;
+		reg = <0x20010000 0x20>;
 		#address-cells = <1>;
 		#size-cells = <1>;
 		clocks = <&cru PCLK_EFUSE>;
diff --git a/arch/arm/boot/dts/rk3188.dtsi b/arch/arm/boot/dts/rk3188.dtsi
index 2298a8d840ba..9e0806cd6f46 100644
--- a/arch/arm/boot/dts/rk3188.dtsi
+++ b/arch/arm/boot/dts/rk3188.dtsi
@@ -203,7 +203,7 @@ cru: clock-controller@20000000 {
 
 	efuse: efuse@20010000 {
 		compatible = "rockchip,rk3188-efuse";
-		reg = <0x20010000 0x4000>;
+		reg = <0x20010000 0x20>;
 		#address-cells = <1>;
 		#size-cells = <1>;
 		clocks = <&cru PCLK_EFUSE>;

From 713a88dec72631a71bf736e120236f60d06f3989 Mon Sep 17 00:00:00 2001
From: Alex Bee <knaerzche@gmail.com>
Date: Sun, 16 Aug 2020 18:51:38 +0200
Subject: [PATCH] ARM: dts: rockchip add operating-points, power-domain for
 RK322Xs GPU

This adds the operating-points table and the power-domain and the respective
qos registers for RK322xs GPU.
While at this it also adds the GPU to be a cooling cell.
---
 arch/arm/boot/dts/rk322x.dtsi | 27 ++++++++++++++++++++++++++-
 1 file changed, 26 insertions(+), 1 deletion(-)

diff --git a/arch/arm/boot/dts/rk322x.dtsi b/arch/arm/boot/dts/rk322x.dtsi
index a5f1d1a004d4..dedf84af9e51 100644
--- a/arch/arm/boot/dts/rk322x.dtsi
+++ b/arch/arm/boot/dts/rk322x.dtsi
@@ -510,6 +510,11 @@ map1 {
 						<&cpu2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
 						<&cpu3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
 				};
+				map2 {
+					trip = <&cpu_alert1>;
+					cooling-device =
+						<&gpu THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+				};
 			};
 		};
 	};
@@ -564,7 +569,27 @@ gpu: gpu@20000000 {
 		clocks = <&cru ACLK_GPU>, <&cru ACLK_GPU>;
 		clock-names = "bus", "core";
 		resets = <&cru SRST_GPU_A>;
-		status = "disabled";
+		operating-points-v2 = <&gpu_opp_table>;
+		#cooling-cells = <2>; /* min followed by max */
+	};
+
+	gpu_opp_table: opp-table2 {
+		compatible = "operating-points-v2";
+
+		opp-300000000 {
+			opp-hz = /bits/ 64 <300000000>;
+			opp-microvolt = <1100000 1000000 1200000>;
+		};
+
+		opp-400000000 {
+			opp-hz = /bits/ 64 <400000000>;
+			opp-microvolt = <1100000 1000000 1200000>;
+		};
+
+		opp-500000000 {
+			opp-hz = /bits/ 64 <500000000>;
+			opp-microvolt = <1100000 1000000 1200000>;
+		};
 	};
 
 	vpu_mmu: iommu@20020800 {

From 4526da0caf4ecc56cc6e6b8602715dbe839c3eac Mon Sep 17 00:00:00 2001
From: Alex Bee <knaerzche@gmail.com>
Date: Sun, 16 Aug 2020 19:44:42 +0200
Subject: [PATCH] ARM: dts: rockchip: add ethernet0 alias

Add ethernet0 alias for gmac. This will, for example, be used
by u-boot to inject a "local-mac-address" in the devicetree.
---
 arch/arm/boot/dts/rk322x.dtsi | 1 +
 1 file changed, 1 insertion(+)

diff --git a/arch/arm/boot/dts/rk322x.dtsi b/arch/arm/boot/dts/rk322x.dtsi
index dedf84af9e51..3c20ee3a7837 100644
--- a/arch/arm/boot/dts/rk322x.dtsi
+++ b/arch/arm/boot/dts/rk322x.dtsi
@@ -14,6 +14,7 @@ / {
 	interrupt-parent = <&gic>;
 
 	aliases {
+		ethernet0 = &gmac;
 		serial0 = &uart0;
 		serial1 = &uart1;
 		serial2 = &uart2;

From 3d6864134434144078395786338b194704a5a41a Mon Sep 17 00:00:00 2001
From: Alex Bee <knaerzche@gmail.com>
Date: Sun, 16 Aug 2020 20:00:01 +0200
Subject: [PATCH] ARM: dts: rockchip: add hdmi simple-audio-card for RK322x

Add "simple-audio-card" definition for hdmi-sound. While at
that also add the missing #sound-dai-cells for i2s, spdif and hdmi
nodes.
---
 arch/arm/boot/dts/rk322x.dtsi | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/arch/arm/boot/dts/rk322x.dtsi b/arch/arm/boot/dts/rk322x.dtsi
index 3c20ee3a7837..d10ca04c20d6 100644
--- a/arch/arm/boot/dts/rk322x.dtsi
+++ b/arch/arm/boot/dts/rk322x.dtsi
@@ -123,6 +123,22 @@ arm-pmu {
 		interrupt-affinity = <&cpu0>, <&cpu1>, <&cpu2>, <&cpu3>;
 	};
 
+	hdmi_sound: hdmi-sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "hdmi-sound";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <256>;
+		status = "disabled";
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s0>;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&hdmi>;
+		};
+	};
+
 	psci {
 		compatible = "arm,psci-1.0", "arm,psci-0.2";
 		method = "smc";
@@ -160,6 +176,7 @@ i2s1: i2s1@100b0000 {
 		dma-names = "tx", "rx";
 		pinctrl-names = "default";
 		pinctrl-0 = <&i2s1_bus>;
+		#sound-dai-cells = <0>;
 		status = "disabled";
 	};
 
@@ -171,6 +188,7 @@ i2s0: i2s0@100c0000 {
 		clocks = <&cru SCLK_I2S0>, <&cru HCLK_I2S0_8CH>;
 		dmas = <&pdma 11>, <&pdma 12>;
 		dma-names = "tx", "rx";
+		#sound-dai-cells = <0>;
 		status = "disabled";
 	};
 
@@ -184,6 +202,7 @@ spdif: spdif@100d0000 {
 		dma-names = "tx";
 		pinctrl-names = "default";
 		pinctrl-0 = <&spdif_tx>;
+		#sound-dai-cells = <0>;
 		status = "disabled";
 	};
 
@@ -685,6 +704,7 @@ hdmi: hdmi@200a0000 {
 		phys = <&hdmi_phy>;
 		phy-names = "hdmi";
 		rockchip,grf = <&grf>;
+		#sound-dai-cells = <0>;
 		status = "disabled";
 
 		ports {

From f917eada6b9f431a797e3bfab7cd06dbd9dfe981 Mon Sep 17 00:00:00 2001
From: Alex Bee <knaerzche@gmail.com>
Date: Sun, 16 Aug 2020 21:16:11 +0200
Subject: [PATCH] ARM: dts: rockchip: add uart1-1 pins for RK322x

Add uart uart1-1 pins.
While at this also correct the uart2 default pinctrl, which is uart21_xfer.
---
 arch/arm/boot/dts/rk322x.dtsi | 19 ++++++++++++++++++-
 1 file changed, 18 insertions(+), 1 deletion(-)

diff --git a/arch/arm/boot/dts/rk322x.dtsi b/arch/arm/boot/dts/rk322x.dtsi
index d10ca04c20d6..f675551391c3 100644
--- a/arch/arm/boot/dts/rk322x.dtsi
+++ b/arch/arm/boot/dts/rk322x.dtsi
@@ -316,7 +316,7 @@ uart2: serial@11030000 {
 		clocks = <&cru SCLK_UART2>, <&cru PCLK_UART2>;
 		clock-names = "baudclk", "apb_pclk";
 		pinctrl-names = "default";
-		pinctrl-0 = <&uart2_xfer>;
+		pinctrl-0 = <&uart21_xfer>;
 		reg-shift = <2>;
 		reg-io-width = <4>;
 		status = "disabled";
@@ -1194,13 +1194,30 @@ uart1_xfer: uart1-xfer {
 						<1 RK_PB2 1 &pcfg_pull_none>;
 			};
 
+			uart11_xfer: uart11-xfer {
+				rockchip,pins = <3 RK_PB6 1 &pcfg_pull_up>,
+						<3 RK_PB5 1 &pcfg_pull_none>;
+			};
+
 			uart1_cts: uart1-cts {
 				rockchip,pins = <1 RK_PB0 1 &pcfg_pull_none>;
 			};
 
+			uart11_cts: uart11-cts {
+				rockchip,pins = <3 RK_PA7 1 &pcfg_pull_none>;
+			};
+
 			uart1_rts: uart1-rts {
 				rockchip,pins = <1 RK_PB3 1 &pcfg_pull_none>;
 			};
+
+			uart11_rts: uart11-rts {
+				rockchip,pins = <3 RK_PA6 1 &pcfg_pull_none>;
+			};
+
+			uart11_rts_gpio: uart11-rts-gpio {
+				rockchip,pins = <3 RK_PA6 RK_FUNC_GPIO &pcfg_pull_none>;
+			};
 		};
 
 		uart2 {

From cbbb85e00a2b19c1e3e9e4d6591c481718e5fb42 Mon Sep 17 00:00:00 2001
From: Alex Bee <knaerzche@gmail.com>
Date: Sun, 16 Aug 2020 21:58:56 +0200
Subject: [PATCH] ARM: dts: rockchip: align mmc* node properties with driver

Add resets, max-frequency and bus-width properties where required to emmc
,sdmmc and sdio nodes. While at that also add the sdmmc_pwr pinctrl which
is required to get the sd-card controller to work, if it was not/wrong
initialized by the bootloader (i.e. u-boot)
---
 arch/arm/boot/dts/rk322x.dtsi | 17 ++++++++++++++---
 1 file changed, 14 insertions(+), 3 deletions(-)

diff --git a/arch/arm/boot/dts/rk322x.dtsi b/arch/arm/boot/dts/rk322x.dtsi
index f675551391c3..8e7a866e39e5 100644
--- a/arch/arm/boot/dts/rk322x.dtsi
+++ b/arch/arm/boot/dts/rk322x.dtsi
@@ -726,9 +726,13 @@ sdmmc: mmc@30000000 {
 		clocks = <&cru HCLK_SDMMC>, <&cru SCLK_SDMMC>,
 			 <&cru SCLK_SDMMC_DRV>, <&cru SCLK_SDMMC_SAMPLE>;
 		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
+		bus-width = <4>;
 		fifo-depth = <0x100>;
+		max-frequency = <150000000>;
 		pinctrl-names = "default";
-		pinctrl-0 = <&sdmmc_clk &sdmmc_cmd &sdmmc_bus4>;
+		pinctrl-0 = <&sdmmc_clk &sdmmc_cmd &sdmmc_bus4 &sdmmc_pwr>;
+		resets = <&cru SRST_SDMMC>;
+		reset-names = "reset";
 		status = "disabled";
 	};
 
@@ -738,10 +742,14 @@ sdio: mmc@30010000 {
 		interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;
 		clocks = <&cru HCLK_SDIO>, <&cru SCLK_SDIO>,
 			 <&cru SCLK_SDIO_DRV>, <&cru SCLK_SDIO_SAMPLE>;
+		bus-width = <4>;
 		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
 		fifo-depth = <0x100>;
+		max-frequency = <150000000>;
 		pinctrl-names = "default";
 		pinctrl-0 = <&sdio_clk &sdio_cmd &sdio_bus4>;
+		resets = <&cru SRST_SDIO>;
+		reset-names = "reset";
 		status = "disabled";
 	};
 
@@ -749,14 +757,13 @@ emmc: mmc@30020000 {
 		compatible = "rockchip,rk3228-dw-mshc", "rockchip,rk3288-dw-mshc";
 		reg = <0x30020000 0x4000>;
 		interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>;
-		clock-frequency = <37500000>;
-		max-frequency = <37500000>;
 		clocks = <&cru HCLK_EMMC>, <&cru SCLK_EMMC>,
 			 <&cru SCLK_EMMC_DRV>, <&cru SCLK_EMMC_SAMPLE>;
 		clock-names = "biu", "ciu", "ciu-drive", "ciu-sample";
 		bus-width = <8>;
 		rockchip,default-sample-phase = <158>;
 		fifo-depth = <0x100>;
+		max-frequency = <150000000>;
 		pinctrl-names = "default";
 		pinctrl-0 = <&emmc_clk &emmc_cmd &emmc_bus8>;
 		resets = <&cru SRST_EMMC>;
@@ -962,6 +969,10 @@ sdmmc_bus4: sdmmc-bus4 {
 						<1 RK_PC4 1 &pcfg_pull_none_drv_12ma>,
 						<1 RK_PC5 1 &pcfg_pull_none_drv_12ma>;
 			};
+
+			sdmmc_pwr: sdmmc-pwr {
+				rockchip,pins = <1 RK_PB6 RK_FUNC_GPIO &pcfg_pull_none>;
+			};
 		};
 
 		sdio {

From 86ae340dabdfbc27ebdb1b43b96d59999dfa4f5a Mon Sep 17 00:00:00 2001
From: Alex Bee <knaerzche@gmail.com>
Date: Sun, 16 Aug 2020 23:12:25 +0200
Subject: [PATCH] ARM: dts: rk322x: add crypto node

In order to add support for RK322x's crypto HW, the node
has been added t its dts.

Signed-off-by: Alex Bee <knaerzche@gmail.com>
---
 arch/arm/boot/dts/rk322x.dtsi | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/arch/arm/boot/dts/rk322x.dtsi b/arch/arm/boot/dts/rk322x.dtsi
index 8e7a866e39e5..217ee6568f9e 100644
--- a/arch/arm/boot/dts/rk322x.dtsi
+++ b/arch/arm/boot/dts/rk322x.dtsi
@@ -166,6 +166,17 @@ display_subsystem: display-subsystem {
 		ports = <&vop_out>;
 	};
 
+	crypto: cypto-controller@100a0000 {
+		compatible = "rockchip,rk3288-crypto";
+		reg = <0x100a0000 0x4000>;
+		interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&cru HCLK_M_CRYPTO>, <&cru HCLK_S_CRYPTO>,
+		<&cru SCLK_CRYPTO>, <&cru ACLK_DMAC>;
+		clock-names = "aclk", "hclk", "sclk", "apb_pclk";
+		resets = <&cru SRST_CRYPTO>;
+		reset-names = "crypto-rst";
+	};
+
 	i2s1: i2s1@100b0000 {
 		compatible = "rockchip,rk3228-i2s", "rockchip,rk3066-i2s";
 		reg = <0x100b0000 0x4000>;

From 17648b3f3533fa800cec162a8278611b2695413c Mon Sep 17 00:00:00 2001
From: Alex Bee <knaerzche@gmail.com>
Date: Thu, 15 Oct 2020 23:37:37 +0200
Subject: [PATCH] ARM: dts: add rk3228 power-domain node

Signed-off-by: Alex Bee <knaerzche@gmail.com>
---
 arch/arm/boot/dts/rk322x.dtsi | 105 ++++++++++++++++++++++++++++++++++
 1 file changed, 105 insertions(+)

diff --git a/arch/arm/boot/dts/rk322x.dtsi b/arch/arm/boot/dts/rk322x.dtsi
index 217ee6568f9e..4bc631881c05 100644
--- a/arch/arm/boot/dts/rk322x.dtsi
+++ b/arch/arm/boot/dts/rk322x.dtsi
@@ -6,6 +6,7 @@
 #include <dt-bindings/pinctrl/rockchip.h>
 #include <dt-bindings/clock/rk3228-cru.h>
 #include <dt-bindings/thermal/thermal.h>
+#include <dt-bindings/power/rk3228-power.h>
 
 / {
 	#address-cells = <1>;
@@ -239,6 +240,61 @@ io_domains: io-domains {
 			status = "disabled";
 		};
 
+		power: power-controller {
+			compatible = "rockchip,rk3228-power-controller";
+			#power-domain-cells = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			pd_vio@RK3228_PD_VIO {
+				reg = <RK3228_PD_VIO>;
+				clocks = <&cru ACLK_HDCP>,
+				         <&cru PCLK_HDCP>,
+				         <&cru SCLK_HDCP>,
+					 <&cru ACLK_IEP>,
+				         <&cru HCLK_IEP>,
+				         <&cru ACLK_RGA>,
+				         <&cru HCLK_RGA>,
+				         <&cru SCLK_RGA>;
+				pm_qos = <&qos_hdcp>,
+					 <&qos_iep>,
+					 <&qos_rga_r>,
+					 <&qos_rga_w>;
+			};
+
+			pd_vop@RK3228_PD_VOP {
+				reg = <RK3228_PD_VOP>;
+				clocks =<&cru ACLK_VOP>,
+					<&cru DCLK_VOP>,
+					<&cru HCLK_VOP>;
+				pm_qos = <&qos_vop>;
+			};
+
+			pd_vpu@RK3228_PD_VPU {
+				reg = <RK3228_PD_VPU>;
+				clocks = <&cru ACLK_VPU>,
+					 <&cru HCLK_VPU>;
+				pm_qos = <&qos_vpu>;
+			};
+
+			pd_rkvdec@RK3228_PD_RKVDEC {
+				reg = <RK3228_PD_RKVDEC>;
+				clocks = <&cru ACLK_RKVDEC>,
+				         <&cru HCLK_RKVDEC>,
+				         <&cru SCLK_VDEC_CABAC>,
+				         <&cru SCLK_VDEC_CORE>;
+				pm_qos = <&qos_rkvdec_r>,
+					 <&qos_rkvdec_w>;
+			};
+
+			pd_gpu@RK3228_PD_GPU {
+				reg = <RK3228_PD_GPU>;
+				clocks = <&cru ACLK_GPU>;
+				pm_qos = <&qos_gpu>;
+			};
+
+		};
+
 		u2phy0: usb2-phy@760 {
 			compatible = "rockchip,rk3228-usb2phy";
 			reg = <0x0760 0x0c>;
@@ -601,6 +657,7 @@ gpu: gpu@20000000 {
 		clock-names = "bus", "core";
 		resets = <&cru SRST_GPU_A>;
 		operating-points-v2 = <&gpu_opp_table>;
+		power-domains = <&power RK3228_PD_GPU>;
 		#cooling-cells = <2>; /* min followed by max */
 	};
 
@@ -654,6 +711,7 @@ vop: vop@20050000 {
 		resets = <&cru SRST_VOP_A>, <&cru SRST_VOP_H>, <&cru SRST_VOP_D>;
 		reset-names = "axi", "ahb", "dclk";
 		iommus = <&vop_mmu>;
+		power-domains = <&power RK3228_PD_VOP>;
 		status = "disabled";
 
 		vop_out: port {
@@ -674,6 +732,7 @@ vop_mmu: iommu@20053f00 {
 		interrupt-names = "vop_mmu";
 		clocks = <&cru ACLK_VOP>, <&cru HCLK_VOP>;
 		clock-names = "aclk", "iface";
+		power-domains = <&power RK3228_PD_VOP>;
 		#iommu-cells = <0>;
 		status = "disabled";
 	};
@@ -686,6 +745,7 @@ rga: rga@20060000 {
 		clock-names = "aclk", "hclk", "sclk";
 		resets = <&cru SRST_RGA>, <&cru SRST_RGA_A>, <&cru SRST_RGA_H>;
 		reset-names = "core", "axi", "ahb";
+		power-domains = <&power RK3228_PD_VIO>;
 	};
 
 	iep_mmu: iommu@20070800 {
@@ -877,6 +937,51 @@ gmac: ethernet@30200000 {
 		status = "disabled";
 	};
 
+	qos_iep: qos@31030080 {
+		compatible = "syscon";
+		reg = <0x31030080 0x20>;
+	};
+
+	qos_rga_w: qos@31030100 {
+		compatible = "syscon";
+		reg = <0x31030100 0x20>;
+	};
+
+	qos_hdcp: qos@31030180 {
+		compatible = "syscon";
+		reg = <0x31030180 0x20>;
+	};
+
+	qos_rga_r: qos@31030200 {
+		compatible = "syscon";
+		reg = <0x31030200 0x20>;
+	};
+
+	qos_vpu: qos@31040000 {
+		compatible = "syscon";
+		reg = <0x31040000 0x20>;
+	};
+
+	qos_gpu: qos@31050000 {
+		compatible = "syscon";
+		reg = <0x31050000 0x20>;
+	};
+
+	qos_vop: qos@31060000 {
+		compatible = "syscon";
+		reg = <0x31060000 0x20>;
+	};
+
+	qos_rkvdec_r: qos@31070000 {
+		compatible = "syscon";
+		reg = <0x31070000 0x20>;
+	};
+
+	qos_rkvdec_w: qos@31070080 {
+		compatible = "syscon";
+		reg = <0x31070080 0x20>;
+	};
+
 	gic: interrupt-controller@32010000 {
 		compatible = "arm,gic-400";
 		interrupt-controller;

From cdd942ba744ff0a9705529776c881f57af0ec96b Mon Sep 17 00:00:00 2001
From: Alex Bee <knaerzche@gmail.com>
Date: Mon, 30 Nov 2020 23:54:22 +0100
Subject: [PATCH] net: arc_emac: fix dma_map* / dma_unmap_* devices

Commit 4e57482e8440 ("dma-direct: Fix potential NULL pointer dereference")
started checking for the existence of dev->dma_mask in dma_map_page_attrs,
which seems reasonable.
However from this commit on emac driver's dma mapping failed. During code
review it turned out, that all dma_map_* dma_unmap_* calls are using the
net-dev (which obviously doesn't have dma_mask attribute). On the other
hand in arc_emac_probe its parent (the actual emac device) is used for
dmam_alloc_coherent.
To fix this the net-dev's parent has to be used dma_map* / dma_unmap_*
calls as well.

Signed-off-by: Alex Bee <knaerzche@gmail.com>
---
 drivers/net/ethernet/arc/emac_main.c | 20 ++++++++++----------
 1 file changed, 10 insertions(+), 10 deletions(-)

diff --git a/drivers/net/ethernet/arc/emac_main.c b/drivers/net/ethernet/arc/emac_main.c
index b56a9e2aecd9..03e3ba81bebd 100644
--- a/drivers/net/ethernet/arc/emac_main.c
+++ b/drivers/net/ethernet/arc/emac_main.c
@@ -140,7 +140,7 @@ static void arc_emac_tx_clean(struct net_device *ndev)
 			stats->tx_bytes += skb->len;
 		}
 
-		dma_unmap_single(&ndev->dev, dma_unmap_addr(tx_buff, addr),
+		dma_unmap_single(ndev->dev.parent, dma_unmap_addr(tx_buff, addr),
 				 dma_unmap_len(tx_buff, len), DMA_TO_DEVICE);
 
 		/* return the sk_buff to system */
@@ -223,9 +223,9 @@ static int arc_emac_rx(struct net_device *ndev, int budget)
 			continue;
 		}
 
-		addr = dma_map_single(&ndev->dev, (void *)skb->data,
+		addr = dma_map_single(ndev->dev.parent, (void *)skb->data,
 				      EMAC_BUFFER_SIZE, DMA_FROM_DEVICE);
-		if (dma_mapping_error(&ndev->dev, addr)) {
+		if (dma_mapping_error(ndev->dev.parent, addr)) {
 			if (net_ratelimit())
 				netdev_err(ndev, "cannot map dma buffer\n");
 			dev_kfree_skb(skb);
@@ -237,7 +237,7 @@ static int arc_emac_rx(struct net_device *ndev, int budget)
 		}
 
 		/* unmap previosly mapped skb */
-		dma_unmap_single(&ndev->dev, dma_unmap_addr(rx_buff, addr),
+		dma_unmap_single(ndev->dev.parent, dma_unmap_addr(rx_buff, addr),
 				 dma_unmap_len(rx_buff, len), DMA_FROM_DEVICE);
 
 		pktlen = info & LEN_MASK;
@@ -445,9 +445,9 @@ static int arc_emac_open(struct net_device *ndev)
 		if (unlikely(!rx_buff->skb))
 			return -ENOMEM;
 
-		addr = dma_map_single(&ndev->dev, (void *)rx_buff->skb->data,
+		addr = dma_map_single(ndev->dev.parent, (void *)rx_buff->skb->data,
 				      EMAC_BUFFER_SIZE, DMA_FROM_DEVICE);
-		if (dma_mapping_error(&ndev->dev, addr)) {
+		if (dma_mapping_error(ndev->dev.parent, addr)) {
 			netdev_err(ndev, "cannot dma map\n");
 			dev_kfree_skb(rx_buff->skb);
 			return -ENOMEM;
@@ -555,7 +555,7 @@ static void arc_free_tx_queue(struct net_device *ndev)
 		struct buffer_state *tx_buff = &priv->tx_buff[i];
 
 		if (tx_buff->skb) {
-			dma_unmap_single(&ndev->dev,
+			dma_unmap_single(ndev->dev.parent,
 					 dma_unmap_addr(tx_buff, addr),
 					 dma_unmap_len(tx_buff, len),
 					 DMA_TO_DEVICE);
@@ -586,7 +586,7 @@ static void arc_free_rx_queue(struct net_device *ndev)
 		struct buffer_state *rx_buff = &priv->rx_buff[i];
 
 		if (rx_buff->skb) {
-			dma_unmap_single(&ndev->dev,
+			dma_unmap_single(ndev->dev.parent,
 					 dma_unmap_addr(rx_buff, addr),
 					 dma_unmap_len(rx_buff, len),
 					 DMA_FROM_DEVICE);
@@ -692,10 +692,10 @@ static netdev_tx_t arc_emac_tx(struct sk_buff *skb, struct net_device *ndev)
 		return NETDEV_TX_BUSY;
 	}
 
-	addr = dma_map_single(&ndev->dev, (void *)skb->data, len,
+	addr = dma_map_single(ndev->dev.parent, (void *)skb->data, len,
 			      DMA_TO_DEVICE);
 
-	if (unlikely(dma_mapping_error(&ndev->dev, addr))) {
+	if (unlikely(dma_mapping_error(ndev->dev.parent, addr))) {
 		stats->tx_dropped++;
 		stats->tx_errors++;
 		dev_kfree_skb_any(skb);

From 04217d19aac7197c97ce132a5f53d21d018de4dd Mon Sep 17 00:00:00 2001
From: Alex Bee <knaerzche@gmail.com>
Date: Tue, 1 Dec 2020 01:03:37 +0100
Subject: [PATCH] net: arc_emac: Add phy fixup for RTL8201F

As stated in RTL8201F's datasheet the powersave functionality
has to be disabled in case the PHY's clock is used as clock
input for the mac interface. (which is the default)
Currently the mac interface is "hanging" for a couple of
seconds whenever there was no TX for some time.
Also EEE capabilities of this phy have to be disabled,
otherwise constant link up / link down events are triggered
when there is no traffic and emac will hang is this case
as well.

Signed-off-by: Alex Bee <knaerzche@gmail.com>
---
 drivers/net/ethernet/arc/emac.h      | 14 +++++++
 drivers/net/ethernet/arc/emac_main.c | 61 ++++++++++++++++++++++++++++
 2 files changed, 75 insertions(+)

diff --git a/drivers/net/ethernet/arc/emac.h b/drivers/net/ethernet/arc/emac.h
index d820ae03a966..0ac87288b97d 100644
--- a/drivers/net/ethernet/arc/emac.h
+++ b/drivers/net/ethernet/arc/emac.h
@@ -91,6 +91,20 @@ struct arc_emac_bd {
 #define RX_RING_SZ	(RX_BD_NUM * sizeof(struct arc_emac_bd))
 #define TX_RING_SZ	(TX_BD_NUM * sizeof(struct arc_emac_bd))
 
+/* PHY fixups */
+#define RTL_8201F_PHY_ID  		0x001cc816
+
+#define RTL_8201F_PG_SELECT_REG 	0x1f
+#define RTL_8201F_PG4_EEE_REG		0x10
+#define RTL_8201F_PG4_EEE_RX_QUIET_EN		BIT(8)
+#define RTL_8201F_PG4_EEE_TX_QUIET_EN		BIT(9)
+#define RTL_8201F_PG4_EEE_NWAY_EN		BIT(12)
+#define RTL_8201F_PG4_EEE_10M_CAP		BIT(13)
+#define RTL_8201F_PG7_RMSR_REG		0x10
+#define RTL_8201F_PG7_RMSR_CLK_DIR_IN		BIT(12)
+#define RTL_8201F_PG0_PSMR_REG		0x18
+#define RTL_8201F_PG0_PSMR_PWRSVE_EN		BIT(15)
+
 /**
  * struct buffer_state - Stores Rx/Tx buffer state.
  * @sk_buff:	Pointer to socket buffer.
diff --git a/drivers/net/ethernet/arc/emac_main.c b/drivers/net/ethernet/arc/emac_main.c
index 03e3ba81bebd..68089df758fa 100644
--- a/drivers/net/ethernet/arc/emac_main.c
+++ b/drivers/net/ethernet/arc/emac_main.c
@@ -850,6 +850,62 @@ static const struct net_device_ops arc_emac_netdev_ops = {
 #endif
 };
 
+/**
+ * arc_emac_rtl8201f_phy_fixup
+ * @phydev: Pointer to phy_device structure.
+ *
+ * This function registers a fixup in case RTL8201F's phy
+ * clockout is used as reference for the mac interface
+ * and disable EEE, since emac can't handle it
+ */
+static int arc_emac_rtl8201f_phy_fixup(struct phy_device *phydev)
+{
+	unsigned int reg, curr_pg;
+	int err = 0;
+
+	curr_pg = phy_read(phydev, RTL_8201F_PG_SELECT_REG);
+	err = phy_write(phydev, RTL_8201F_PG_SELECT_REG, 4);
+	if (err)
+		goto out_err;
+	mdelay(10);
+
+	/* disable EEE */
+	reg = phy_read(phydev, RTL_8201F_PG4_EEE_REG);
+	reg &=  ~RTL_8201F_PG4_EEE_RX_QUIET_EN &
+		~RTL_8201F_PG4_EEE_TX_QUIET_EN &
+		~RTL_8201F_PG4_EEE_NWAY_EN &
+		~RTL_8201F_PG4_EEE_10M_CAP;
+	err = phy_write(phydev, RTL_8201F_PG4_EEE_REG, reg);
+	if (err)
+		goto out_err;
+
+	if (phydev->interface == PHY_INTERFACE_MODE_RMII) {
+		err = phy_write(phydev, RTL_8201F_PG_SELECT_REG, 7);
+		if (err)
+			goto out_err;
+		mdelay(10);
+
+		reg = phy_read(phydev, RTL_8201F_PG7_RMSR_REG);
+		err = phy_write(phydev, RTL_8201F_PG_SELECT_REG, 0);
+		if (err)
+			goto out_err;
+		mdelay(10);
+
+		if (!(reg & RTL_8201F_PG7_RMSR_CLK_DIR_IN)) {
+			/* disable powersave if phy's clock output is used */
+			reg = phy_read(phydev, RTL_8201F_PG0_PSMR_REG);
+			reg &= ~RTL_8201F_PG0_PSMR_PWRSVE_EN & 0xffff;
+			err = phy_write(phydev, RTL_8201F_PG0_PSMR_REG, reg);
+		}
+	}
+
+out_err:
+	phy_write(phydev, RTL_8201F_PG_SELECT_REG, curr_pg);
+	mdelay(10);
+
+	return err;
+};
+
 int arc_emac_probe(struct net_device *ndev, int interface)
 {
 	struct device *dev = ndev->dev.parent;
@@ -974,6 +1030,11 @@ int arc_emac_probe(struct net_device *ndev, int interface)
 		goto out_clken;
 	}
 
+	err = phy_register_fixup_for_uid(RTL_8201F_PHY_ID, 0xfffff0,
+					 arc_emac_rtl8201f_phy_fixup);
+	if (err)
+		dev_warn(dev, "Cannot register PHY board fixup.\n");
+
 	phydev = of_phy_connect(ndev, phy_node, arc_emac_adjust_link, 0,
 				interface);
 	if (!phydev) {

From b9de203365b74ee111d977424ed3fe8d325cc39b Mon Sep 17 00:00:00 2001
From: Alex Bee <knaerzche@gmail.com>
Date: Mon, 30 Nov 2020 21:12:12 +0100
Subject: [PATCH] ARM: dts: rk3xx add L2 properties

As per vendor source, these properties have to be set. It has been
oberserved without them, cpu(s) might hang on boot process.

Signed-off-by: Alex Bee <knaerzche@gmail.com>
---
 arch/arm/boot/dts/rk3xxx.dtsi | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/arch/arm/boot/dts/rk3xxx.dtsi b/arch/arm/boot/dts/rk3xxx.dtsi
index 97415180d5bb..d04391e8ee7c 100644
--- a/arch/arm/boot/dts/rk3xxx.dtsi
+++ b/arch/arm/boot/dts/rk3xxx.dtsi
@@ -99,6 +99,8 @@ L2: cache-controller@10138000 {
 		reg = <0x10138000 0x1000>;
 		cache-unified;
 		cache-level = <2>;
+		prefetch-data = <1>;
+		prefetch-instr = <1>;
 	};
 
 	scu@1013c000 {
