diff -ruPN linux/drivers/input/Kconfig linux-new/drivers/input/Kconfig
--- linux/drivers/input/Kconfig	2022-04-13 21:01:11.000000000 +0200
+++ linux-new/drivers/input/Kconfig	2022-04-15 11:13:41.130840776 +0200
@@ -199,6 +199,8 @@
 
 source "drivers/input/misc/Kconfig"
 
+source "drivers/input/remotectl/Kconfig"
+
 source "drivers/input/rmi4/Kconfig"
 
 endif
diff -ruPN linux/drivers/input/Makefile linux-new/drivers/input/Makefile
--- linux/drivers/input/Makefile	2022-04-13 21:01:11.000000000 +0200
+++ linux-new/drivers/input/Makefile	2022-04-15 11:13:41.131840776 +0200
@@ -23,6 +23,7 @@
 obj-$(CONFIG_INPUT_MOUSE)	+= mouse/
 obj-$(CONFIG_INPUT_JOYSTICK)	+= joystick/
 obj-$(CONFIG_INPUT_TABLET)	+= tablet/
+obj-$(CONFIG_ROCKCHIP_REMOTECTL)+= remotectl/
 obj-$(CONFIG_INPUT_TOUCHSCREEN)	+= touchscreen/
 obj-$(CONFIG_INPUT_MISC)	+= misc/
 
diff -ruPN linux/drivers/input/remotectl/Kconfig linux-new/drivers/input/remotectl/Kconfig
--- linux/drivers/input/remotectl/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-new/drivers/input/remotectl/Kconfig	2022-04-15 11:13:41.131840776 +0200
@@ -0,0 +1,19 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Input remotectl driver configuration
+#
+menuconfig ROCKCHIP_REMOTECTL
+	tristate "rockchip remotectl"
+	default n
+	help
+	  Say Y here, will suport rk remotectl.
+	  This option doesn't affect the kernel.
+	  If unsure, say Y.
+
+if ROCKCHIP_REMOTECTL
+
+config ROCKCHIP_REMOTECTL_PWM
+	tristate "rockchip remoctrl pwm capture"
+	default n
+
+endif
diff -ruPN linux/drivers/input/remotectl/Makefile linux-new/drivers/input/remotectl/Makefile
--- linux/drivers/input/remotectl/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-new/drivers/input/remotectl/Makefile	2022-04-15 11:13:41.131840776 +0200
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for the input remotectl drivers.
+#
+
+# Each configuration option enables a list of files.
+
+obj-$(CONFIG_ROCKCHIP_REMOTECTL_PWM)	+= rockchip_pwm_remotectl.o
diff -ruPN linux/drivers/input/remotectl/rockchip_pwm_remotectl.c linux-new/drivers/input/remotectl/rockchip_pwm_remotectl.c
--- linux/drivers/input/remotectl/rockchip_pwm_remotectl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-new/drivers/input/remotectl/rockchip_pwm_remotectl.c	2022-04-19 11:22:18.551311823 +0200
@@ -0,0 +1,856 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#include <linux/arm-smccc.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/irqdesc.h>
+#include <linux/irqdomain.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/leds.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+#include <linux/slab.h>
+#include <soc/rockchip/rockchip_sip.h>
+#include "rockchip_pwm_remotectl.h"
+
+/*
+ * sys/module/rk_pwm_remotectl/parameters,
+ * modify code_print to change the value
+ */
+
+static int rk_remote_print_code;
+module_param_named(code_print, rk_remote_print_code, int, 0644);
+#define DBG_CODE(args...) \
+	do { \
+		if (rk_remote_print_code) { \
+			pr_info(args); \
+		} \
+	} while (0)
+
+static int rk_remote_pwm_dbg_level;
+module_param_named(dbg_level, rk_remote_pwm_dbg_level, int, 0644);
+#define DBG(args...) \
+	do { \
+		if (rk_remote_pwm_dbg_level) { \
+			pr_info(args); \
+		} \
+	} while (0)
+
+
+struct rkxx_remote_key_table {
+	int scancode;
+	int keycode;
+};
+
+struct rkxx_remotectl_button {
+	int usercode;
+	int nbuttons;
+	struct rkxx_remote_key_table key_table[MAX_NUM_KEYS];
+};
+
+struct rkxx_remotectl_drvdata {
+	void __iomem *base;
+	int state;
+	int nbuttons;
+	int scandata;
+	int count;
+	int keynum;
+	int maxkeybdnum;
+	int keycode;
+	int press;
+	int pre_press;
+	int irq;
+	int remote_pwm_id;
+	int handle_cpu_id;
+	int wakeup;
+	int support_psci;
+	int pwm_pwrkey_capture;
+	unsigned long period;
+	unsigned long temp_period;
+	int pwm_freq_nstime;
+	int pwrkey_wakeup;
+	struct input_dev *input;
+	struct timer_list timer;
+	struct tasklet_struct remote_tasklet;
+	struct wakeup_source *remotectl_wake_lock;
+};
+
+static struct rkxx_remotectl_button *remotectl_button;
+
+static struct led_trigger *led_feedback;
+
+static int remotectl_keybd_num_lookup(struct rkxx_remotectl_drvdata *ddata)
+{
+	int i;
+	int num;
+
+	num = ddata->maxkeybdnum;
+	for (i = 0; i < num; i++) {
+		if (remotectl_button[i].usercode == (ddata->scandata&0xFFFF)) {
+			ddata->keynum = i;
+			return 1;
+		}
+	}
+	return 0;
+}
+
+
+static int remotectl_keycode_lookup(struct rkxx_remotectl_drvdata *ddata)
+{
+	int i;
+	unsigned char keydata = (unsigned char)((ddata->scandata >> 8) & 0xff);
+
+	for (i = 0; i < remotectl_button[ddata->keynum].nbuttons; i++) {
+		if (remotectl_button[ddata->keynum].key_table[i].scancode ==
+		    keydata) {
+			ddata->keycode =
+			remotectl_button[ddata->keynum].key_table[i].keycode;
+			return 1;
+		}
+	}
+	return 0;
+}
+
+static int rk_remotectl_get_irkeybd_count(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct device_node *child_node;
+	int boardnum;
+	int temp_usercode;
+
+	boardnum = 0;
+	for_each_child_of_node(node, child_node) {
+		if (of_property_read_u32(child_node, "rockchip,usercode",
+			&temp_usercode)) {
+			DBG("get keybd num error.\n");
+		} else {
+			boardnum++;
+		}
+	}
+	DBG("get keybd num = 0x%x.\n", boardnum);
+	return boardnum;
+}
+
+
+static int rk_remotectl_parse_ir_keys(struct platform_device *pdev)
+{
+	struct rkxx_remotectl_drvdata *ddata = platform_get_drvdata(pdev);
+	struct device_node *node = pdev->dev.of_node;
+	struct device_node *child_node;
+	int loop;
+	int ret;
+	int len;
+	int boardnum;
+
+	boardnum = 0;
+	for_each_child_of_node(node, child_node) {
+		if (of_property_read_u32(child_node, "rockchip,usercode",
+			 &remotectl_button[boardnum].usercode)) {
+			dev_err(&pdev->dev, "Missing usercode in the DTS.\n");
+			ret = -1;
+			return ret;
+		}
+		DBG("remotectl_button[0].usercode=0x%x\n",
+				remotectl_button[boardnum].usercode);
+		of_get_property(child_node, "rockchip,key_table", &len);
+		len /= sizeof(u32);
+		DBG("len=0x%x\n", len);
+		remotectl_button[boardnum].nbuttons = len/2;
+		if (of_property_read_u32_array(child_node, "rockchip,key_table",
+			 (u32 *)remotectl_button[boardnum].key_table, len)) {
+			dev_err(&pdev->dev, "Missing key_table in the DTS.\n");
+			ret = -1;
+			return ret;
+		}
+		for (loop = 0; loop < (len/2); loop++) {
+			DBG("board[%d].scanCode[%d]=0x%x\n", boardnum, loop,
+			     remotectl_button[boardnum].key_table[loop].scancode);
+			DBG("board[%d].keyCode[%d]=%d\n", boardnum, loop,
+			     remotectl_button[boardnum].key_table[loop].keycode);
+		}
+		boardnum++;
+		if (boardnum > ddata->maxkeybdnum)
+			break;
+	}
+	DBG("keybdNum=0x%x\n", boardnum);
+	return 0;
+}
+
+
+
+static void rk_pwm_remotectl_do_something(unsigned long  data)
+{
+	struct rkxx_remotectl_drvdata *ddata;
+
+	ddata = (struct rkxx_remotectl_drvdata *)data;
+	switch (ddata->state) {
+	case RMC_IDLE: {
+		;
+		break;
+	}
+	case RMC_PRELOAD: {
+		mod_timer(&ddata->timer, jiffies + msecs_to_jiffies(140));
+		if ((ddata->period > RK_PWM_TIME_PRE_MIN) &&
+		    (ddata->period < RK_PWM_TIME_PRE_MAX)) {
+			ddata->scandata = 0;
+			ddata->count = 0;
+			ddata->state = RMC_USERCODE;
+		} else {
+			ddata->state = RMC_PRELOAD;
+		}
+		break;
+	}
+	case RMC_USERCODE: {
+		if ((ddata->period > RK_PWM_TIME_BIT1_MIN) &&
+		    (ddata->period < RK_PWM_TIME_BIT1_MAX))
+			ddata->scandata |= (0x01 << ddata->count);
+		ddata->count++;
+		if (ddata->count == 0x10) {
+			DBG_CODE("USERCODE=0x%x\n", ddata->scandata);
+			if (remotectl_keybd_num_lookup(ddata)) {
+				ddata->state = RMC_GETDATA;
+				ddata->scandata = 0;
+				ddata->count = 0;
+			} else {
+				if (rk_remote_print_code) {
+					ddata->state = RMC_GETDATA;
+					ddata->scandata = 0;
+					ddata->count = 0;
+				} else
+					ddata->state = RMC_PRELOAD;
+			}
+		}
+	}
+	break;
+	case RMC_GETDATA: {
+		if ((ddata->period > RK_PWM_TIME_BIT1_MIN) &&
+		    (ddata->period < RK_PWM_TIME_BIT1_MAX))
+			ddata->scandata |= (0x01<<ddata->count);
+		ddata->count++;
+		if (ddata->count < 0x10)
+			return;
+		DBG_CODE("RMC_GETDATA=%x\n", (ddata->scandata>>8));
+		if ((ddata->scandata&0x0ff) ==
+		    ((~ddata->scandata >> 8) & 0x0ff)) {
+			if (remotectl_keycode_lookup(ddata)) {
+				led_trigger_event(led_feedback, LED_OFF);
+				ddata->press = 1;
+				input_event(ddata->input, EV_KEY,
+					    ddata->keycode, 1);
+				input_sync(ddata->input);
+				ddata->state = RMC_SEQUENCE;
+			} else {
+				ddata->state = RMC_PRELOAD;
+			}
+		} else {
+			ddata->state = RMC_PRELOAD;
+		}
+	}
+	break;
+	case RMC_SEQUENCE:{
+		DBG("S=%ld\n", ddata->period);
+		if ((ddata->period > RK_PWM_TIME_RPT_MIN) &&
+		    (ddata->period < RK_PWM_TIME_RPT_MAX)) {
+			DBG("S1\n");
+			mod_timer(&ddata->timer, jiffies
+				  + msecs_to_jiffies(130));
+		} else if ((ddata->period > RK_PWM_TIME_SEQ1_MIN) &&
+			   (ddata->period < RK_PWM_TIME_SEQ1_MAX)) {
+			DBG("S2\n");
+			mod_timer(&ddata->timer, jiffies
+				  + msecs_to_jiffies(130));
+		} else if ((ddata->period > RK_PWM_TIME_SEQ2_MIN) &&
+			   (ddata->period < RK_PWM_TIME_SEQ2_MAX)) {
+			DBG("S3\n");
+			mod_timer(&ddata->timer, jiffies
+				  + msecs_to_jiffies(130));
+		} else {
+			DBG("S4\n");
+			input_event(ddata->input, EV_KEY,
+				    ddata->keycode, 0);
+			input_sync(ddata->input);
+			ddata->state = RMC_PRELOAD;
+			ddata->press = 0;
+			led_trigger_event(led_feedback, LED_FULL);
+		}
+	}
+	break;
+	default:
+	break;
+	}
+}
+
+static void rk_pwm_remotectl_timer(struct timer_list *t)
+{
+	struct rkxx_remotectl_drvdata *ddata = from_timer(ddata, t, timer);
+
+	if (ddata->press != ddata->pre_press) {
+		ddata->pre_press = 0;
+		ddata->press = 0;
+		input_event(ddata->input, EV_KEY, ddata->keycode, 0);
+		input_sync(ddata->input);
+		led_trigger_event(led_feedback, LED_FULL);
+	}
+	ddata->state = RMC_PRELOAD;
+}
+
+static irqreturn_t rockchip_pwm_pwrirq(int irq, void *dev_id)
+{
+	struct rkxx_remotectl_drvdata *ddata = dev_id;
+	int val;
+	unsigned int id = ddata->remote_pwm_id;
+
+	if (id > 3)
+		return IRQ_NONE;
+
+	val = readl_relaxed(ddata->base + PWM_REG_INTSTS(id));
+
+	if (val & PWM_PWR_KEY_INT) {
+		DBG("pwr=0x%x\n", readl_relaxed(ddata->base + PWM_PWRCAPTURE_VALUE(id)));
+		writel_relaxed(PWM_PWR_KEY_INT, ddata->base + PWM_REG_INTSTS(id));
+		ddata->pwrkey_wakeup = 1;
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+
+static irqreturn_t rockchip_pwm_irq(int irq, void *dev_id)
+{
+	struct rkxx_remotectl_drvdata *ddata = dev_id;
+	int val;
+	int temp_hpr;
+	int temp_lpr;
+	int temp_period;
+	unsigned int id = ddata->remote_pwm_id;
+
+	if (id > 3)
+		return IRQ_NONE;
+	val = readl_relaxed(ddata->base + PWM_REG_INTSTS(id));
+
+	if ((val & PWM_CH_INT(id)) == 0)
+		return IRQ_NONE;
+	if ((val & PWM_CH_POL(id)) == 0) {
+		temp_hpr = readl_relaxed(ddata->base + PWM_REG_HPR);
+		DBG("hpr=%d\n", temp_hpr);
+		temp_lpr = readl_relaxed(ddata->base + PWM_REG_LPR);
+		DBG("lpr=%d\n", temp_lpr);
+		temp_period = ddata->pwm_freq_nstime * temp_lpr / 1000;
+		if (temp_period > RK_PWM_TIME_BIT0_MIN) {
+			ddata->period = ddata->temp_period
+			    + ddata->pwm_freq_nstime * temp_hpr / 1000;
+			tasklet_hi_schedule(&ddata->remote_tasklet);
+			ddata->temp_period = 0;
+			DBG("period+ =%ld\n", ddata->period);
+		} else {
+			ddata->temp_period += ddata->pwm_freq_nstime
+			    * (temp_hpr + temp_lpr) / 1000;
+		}
+	}
+	writel_relaxed(PWM_CH_INT(id), ddata->base + PWM_REG_INTSTS(id));
+	/*if (ddata->state == RMC_PRELOAD)
+		__pm_wakeup_event(ddata->remotectl_wake_lock, HZ);*/
+	return IRQ_HANDLED;
+}
+
+static int rk_pwm_pwrkey_wakeup_init(struct platform_device *pdev)
+{
+	struct rkxx_remotectl_drvdata *ddata = platform_get_drvdata(pdev);
+	int val, min_temp, max_temp;
+	unsigned int pwm_id = ddata->remote_pwm_id;
+	int version;
+	int i, j;
+	int num = 0;
+	int ret = -1;
+	int pwr_irq;
+
+	ddata->pwm_pwrkey_capture = 0;
+	version = readl_relaxed(ddata->base + RK_PWM_VERSION_ID(pwm_id));
+	dev_info(&pdev->dev, "pwm version is 0x%x\n", version & 0xffff0000);
+	if (((version >> 24) & 0xFF) < 2) {
+		dev_info(&pdev->dev, "pwm version is less v2.0\n");
+		goto end;
+	}
+	pwr_irq = platform_get_irq(pdev, 1);
+	if (pwr_irq < 0) {
+		dev_err(&pdev->dev, "cannot find PWR IRQ\n");
+		goto end;
+	}
+	ret = devm_request_irq(&pdev->dev, pwr_irq, rockchip_pwm_pwrirq,
+			       IRQF_NO_SUSPEND, "rk_pwm_pwr_irq", ddata);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot claim PWR_IRQ!!!\n");
+		goto end;
+	}
+	val = readl_relaxed(ddata->base + PWM_REG_CTRL);
+	val = (val & 0xFFFFFFFE) | PWM_DISABLE;
+	writel_relaxed(val, ddata->base + PWM_REG_CTRL);
+
+	//preloader low min:8000us, max:10000us
+	min_temp = RK_PWM_TIME_PRE_MIN_LOW * 1000 / ddata->pwm_freq_nstime;
+	max_temp = RK_PWM_TIME_PRE_MAX_LOW * 1000 / ddata->pwm_freq_nstime;
+	val = (max_temp & 0xffff) << 16 | (min_temp & 0xffff);
+	writel_relaxed(val, ddata->base + PWM_REG_PWRMATCH_LPRE(pwm_id));
+
+	//preloader higt min:4000us, max:5000us
+	min_temp = RK_PWM_TIME_PRE_MIN * 1000 / ddata->pwm_freq_nstime;
+	max_temp = RK_PWM_TIME_PRE_MAX * 1000 / ddata->pwm_freq_nstime;
+	val = (max_temp & 0xffff) << 16 | (min_temp & 0xffff);
+	writel_relaxed(val, ddata->base + PWM_REG_PWRMATCH_HPRE(pwm_id));
+
+	//logic 0/1 low min:480us, max 700us
+	min_temp = RK_PWM_TIME_BIT_MIN_LOW * 1000 / ddata->pwm_freq_nstime;
+	max_temp = RK_PWM_TIME_BIT_MAX_LOW * 1000 / ddata->pwm_freq_nstime;
+	val = (max_temp & 0xffff) << 16 | (min_temp & 0xffff);
+	writel_relaxed(val, ddata->base + PWM_REG_PWRMATCH_LD(pwm_id));
+
+	//logic 0 higt min:480us, max 700us
+	min_temp = RK_PWM_TIME_BIT0_MIN * 1000 / ddata->pwm_freq_nstime;
+	max_temp = RK_PWM_TIME_BIT0_MAX * 1000 / ddata->pwm_freq_nstime;
+	val = (max_temp & 0xffff) << 16 | (min_temp & 0xffff);
+	writel_relaxed(val, ddata->base + PWM_REG_PWRMATCH_HD_ZERO(pwm_id));
+
+	//logic 1 higt min:1300us, max 2000us
+	min_temp = RK_PWM_TIME_BIT1_MIN * 1000 / ddata->pwm_freq_nstime;
+	max_temp = RK_PWM_TIME_BIT1_MAX * 1000 / ddata->pwm_freq_nstime;
+	val = (max_temp & 0xffff) << 16 | (min_temp & 0xffff);
+	writel_relaxed(val, ddata->base + PWM_REG_PWRMATCH_HD_ONE(pwm_id));
+
+	for (j = 0; j < ddata->maxkeybdnum; j++) {
+		for (i = 0; i < remotectl_button[j].nbuttons; i++) {
+			int scancode, usercode, pwrkey;
+
+			if (remotectl_button[j].key_table[i].keycode != KEY_POWER)
+				continue;
+			usercode = remotectl_button[j].usercode & 0xffff;
+			scancode = remotectl_button[j].key_table[i].scancode & 0xff;
+			DBG("usercode=%x, key=%x\n", usercode, scancode);
+			pwrkey  = usercode;
+			pwrkey |= (scancode << 24) | ((~scancode & 0xff) << 16);
+			DBG("pwrkey = %x\n", pwrkey);
+			writel_relaxed(pwrkey, ddata->base
+					+ PWM_PWRMATCH_VALUE(pwm_id) + num * 4);
+			num++;
+			if (num >= PWM_PWR_KEY_CAPURURE_MAX)
+				break;
+		}
+	}
+
+	val = readl_relaxed(ddata->base + PWM_REG_INT_EN(pwm_id));
+	val = (val & 0xFFFFFF7F) | PWM_PWR_INT_ENABLE;
+	writel_relaxed(val, ddata->base + PWM_REG_INT_EN(pwm_id));
+
+	val = CH3_PWRKEY_ENABLE;
+	writel_relaxed(val, ddata->base + PWM_REG_PWRMATCH_CTRL(pwm_id));
+
+	val = readl_relaxed(ddata->base + PWM_REG_CTRL);
+	val = (val & 0xFFFFFFFE) | PWM_ENABLE;
+	writel_relaxed(val, ddata->base + PWM_REG_CTRL);
+	ddata->pwm_pwrkey_capture = 1;
+end:
+	return ret;
+}
+
+static void rk_pwm_int_ctrl(void __iomem *pwm_base, uint pwm_id, int ctrl)
+{
+	int val;
+
+	if (pwm_id > 3)
+		return;
+	val = readl_relaxed(pwm_base + PWM_REG_INT_EN(pwm_id));
+	if (ctrl) {
+		val |= PWM_CH_INT_ENABLE(pwm_id);
+		DBG("pwm int enabled, value is 0x%x\n", val);
+		writel_relaxed(val, pwm_base + PWM_REG_INT_EN(pwm_id));
+	} else {
+		val &= ~PWM_CH_INT_ENABLE(pwm_id);
+		DBG("pwm int disabled, value is 0x%x\n", val);
+	}
+	writel_relaxed(val, pwm_base + PWM_REG_INT_EN(pwm_id));
+}
+
+static int rk_pwm_remotectl_hw_init(void __iomem *pwm_base, uint pwm_id)
+{
+	int val;
+
+	if (pwm_id > 3)
+		return -1;
+	//1. disabled pwm
+	val = readl_relaxed(pwm_base + PWM_REG_CTRL);
+	val = (val & 0xFFFFFFFE) | PWM_DISABLE;
+	writel_relaxed(val, pwm_base + PWM_REG_CTRL);
+	//2. capture mode
+	val = readl_relaxed(pwm_base + PWM_REG_CTRL);
+	val = (val & 0xFFFFFFF9) | PWM_MODE_CAPTURE;
+	writel_relaxed(val, pwm_base + PWM_REG_CTRL);
+	//set clk div, clk div to 64
+	val = readl_relaxed(pwm_base + PWM_REG_CTRL);
+	val = (val & 0xFF0001FF) | PWM_DIV64;
+	writel_relaxed(val, pwm_base + PWM_REG_CTRL);
+	//4. enabled pwm int
+	rk_pwm_int_ctrl(pwm_base, pwm_id, PWM_INT_ENABLE);
+	//5. enabled pwm
+	val = readl_relaxed(pwm_base + PWM_REG_CTRL);
+	val = (val & 0xFFFFFFFE) | PWM_ENABLE;
+	writel_relaxed(val, pwm_base + PWM_REG_CTRL);
+	return 0;
+}
+
+static int rk_pwm_sip_wakeup_init(struct platform_device *pdev)
+{
+	struct rkxx_remotectl_drvdata *ddata = platform_get_drvdata(pdev);
+	struct device_node *np = pdev->dev.of_node;
+	struct irq_desc *desc;
+	int support_psci = 0;
+	int irq;
+	int hwirq;
+	int i, j;
+	int num;
+	int pwm_id;
+	int ret = -1;
+	struct arm_smccc_res res;
+
+	if (of_property_read_u32(np, "remote_support_psci", &support_psci)) {
+		dev_info(&pdev->dev, "PWM Missing psci property in the DT.\n");
+		goto end;
+	}
+
+	arm_smccc_smc(ROCKCHIP_SIP_SIP_VERSION, ROCKCHIP_SIP_IMPLEMENT_V2, SECURE_REG_WR, 0, 0, 0, 0, 0, &res);
+
+	ret = res.a0;
+	if (ret) {
+		dev_err(&pdev->dev, "%s: set rockchip sip version v2 failed\n", __func__);
+		goto end;
+	}
+
+	dev_info(&pdev->dev, "Rockchip SIP initialized, for remote version 0x%lx\n", res.a1);
+
+	DBG("support_psci=0x%x\n", support_psci);
+	if (!support_psci)
+		goto end;
+	irq = ddata->irq;
+	desc = irq_to_desc(irq);
+	if (!desc || !desc->irq_data.domain)
+		goto end;
+	hwirq = desc->irq_data.hwirq;
+	arm_smccc_smc(ROCKCHIP_SIP_REMOTECTL_CFG, ROCKCHIP_REMOTECTL_SET_IRQ, hwirq, 0, 0, 0, 0, 0, &res); //sip_smc_remotectl_config(REMOTECTL_SET_IRQ, hwirq);
+	ret = res.a0;
+	if (ret) {
+		dev_err(&pdev->dev, "set irq err, set support_psci to 0 !!\n");
+		/*
+		 * if atf doesn't support, return probe success to abandon atf
+		 * function and still use kernel pwm parse function
+		 */
+		goto end;
+	}
+	pwm_id = ddata->remote_pwm_id;
+	num = ddata->maxkeybdnum;
+	arm_smccc_smc(ROCKCHIP_SIP_REMOTECTL_CFG, ROCKCHIP_REMOTECTL_SET_PWM_CH, pwm_id, 0, 0, 0, 0, 0, &res);
+	//sip_smc_remotectl_config(REMOTECTL_SET_PWM_CH, pwm_id);
+	for (j = 0; j < num; j++) {
+		for (i = 0; i < remotectl_button[j].nbuttons; i++) {
+			int scancode, pwrkey;
+
+			if (remotectl_button[j].key_table[i].keycode
+			    != KEY_POWER)
+				continue;
+			scancode = remotectl_button[j].key_table[i].scancode;
+			DBG("usercode=%x, key=%x\n",
+			    remotectl_button[j].usercode, scancode);
+			pwrkey = (remotectl_button[j].usercode & 0xffff) << 16;
+			pwrkey |= (scancode & 0xff) << 8;
+			DBG("deliver: key=%x\n", pwrkey);
+			arm_smccc_smc(ROCKCHIP_SIP_REMOTECTL_CFG, ROCKCHIP_REMOTECTL_SET_PWRKEY, pwrkey, 0, 0, 0, 0, 0, &res);
+            /*sip_smc_remotectl_config(REMOTECTL_SET_PWRKEY,
+							pwrkey);*/
+		}
+	}
+	arm_smccc_smc(ROCKCHIP_SIP_REMOTECTL_CFG, ROCKCHIP_REMOTECTL_ENABLE, 1, 0, 0, 0, 0, 0, &res);
+	//sip_smc_remotectl_config(REMOTECTL_ENABLE, 1);
+	ddata->support_psci = support_psci;
+	dev_info(&pdev->dev, "rk pwm sip init end!\n");
+	return 0;
+end:
+	dev_info(&pdev->dev, "pwm sip wakeup config error!!\n");
+	ddata->support_psci = 0;
+	return ret;
+}
+
+static inline void rk_pwm_wakeup(struct input_dev *input)
+{
+	input_event(input, EV_KEY, KEY_POWER, 1);
+	input_event(input, EV_KEY, KEY_POWER, 0);
+	input_sync(input);
+}
+
+static int rk_pwm_probe(struct platform_device *pdev)
+{
+	struct rkxx_remotectl_drvdata *ddata;
+	struct device_node *np = pdev->dev.of_node;
+	struct resource *r;
+	struct input_dev *input;
+	struct clk *clk;
+	struct clk *p_clk;
+	struct cpumask cpumask;
+	int num;
+	int irq;
+	int ret;
+	int i, j;
+	int cpu_id;
+	int pwm_id;
+	int pwm_freq;
+	int count;
+
+	dev_info(&pdev->dev, "rk pwm remotectl v2.0 init\n");
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r) {
+		dev_err(&pdev->dev, "no memory resources defined\n");
+		return -ENODEV;
+	}
+	ddata = devm_kzalloc(&pdev->dev, sizeof(struct rkxx_remotectl_drvdata),
+			     GFP_KERNEL);
+	if (!ddata) {
+		dev_err(&pdev->dev, "failed to allocate memory\n");
+		return -ENOMEM;
+	}
+	ddata->state = RMC_PRELOAD;
+	ddata->temp_period = 0;
+	ddata->base = devm_ioremap_resource(&pdev->dev, r);
+	if (IS_ERR(ddata->base))
+		return PTR_ERR(ddata->base);
+	count = of_property_count_strings(np, "clock-names");
+	if (count == 2) {
+		clk = devm_clk_get(&pdev->dev, "pwm");
+		p_clk = devm_clk_get(&pdev->dev, "pclk");
+	} else {
+		clk = devm_clk_get(&pdev->dev, NULL);
+		p_clk = clk;
+	}
+	if (IS_ERR(clk)) {
+		ret = PTR_ERR(clk);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Can't get bus clk: %d\n", ret);
+		return ret;
+	}
+	if (IS_ERR(p_clk)) {
+		ret = PTR_ERR(p_clk);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Can't get periph clk: %d\n", ret);
+		return ret;
+	}
+	ret = clk_prepare_enable(clk);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't enable bus clk: %d\n", ret);
+		return ret;
+	}
+	ret = clk_prepare_enable(p_clk);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't enable bus periph clk: %d\n", ret);
+		goto error_clk;
+	}
+	platform_set_drvdata(pdev, ddata);
+	num = rk_remotectl_get_irkeybd_count(pdev);
+	if (num == 0) {
+		dev_err(&pdev->dev, "remotectl: no ir keyboard add in dts!!\n");
+		ret = -EINVAL;
+		goto error_pclk;
+	}
+	ddata->maxkeybdnum = num;
+	remotectl_button = devm_kzalloc(&pdev->dev,
+					num * sizeof(struct rkxx_remotectl_button),
+					GFP_KERNEL);
+	if (!remotectl_button) {
+		dev_err(&pdev->dev, "failed to malloc remote button memory\n");
+		ret = -ENOMEM;
+		goto error_pclk;
+	}
+	input = devm_input_allocate_device(&pdev->dev);
+	if (!input) {
+		dev_err(&pdev->dev, "failed to allocate input device\n");
+		ret = -ENOMEM;
+		goto error_pclk;
+	}
+	input->name = pdev->name;
+	input->phys = "gpio-keys/remotectl";
+	input->dev.parent = &pdev->dev;
+	input->id.bustype = BUS_HOST;
+	input->id.vendor = 0x524b;
+	input->id.product = 0x0006;
+	input->id.version = 0x0100;
+	ddata->input = input;
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "cannot find IRQ\n");
+		goto error_pclk;
+	}
+	ddata->irq = irq;
+	ddata->wakeup = 1;
+	of_property_read_u32(np, "remote_pwm_id", &pwm_id);
+	pwm_id %= 4;
+	ddata->remote_pwm_id = pwm_id;
+	if (pwm_id > 3) {
+		dev_err(&pdev->dev, "pwm id error\n");
+		goto error_pclk;
+	}
+	DBG("remotectl: remote pwm id=0x%x\n", pwm_id);
+	of_property_read_u32(np, "handle_cpu_id", &cpu_id);
+	ddata->handle_cpu_id = cpu_id;
+	DBG("remotectl: handle cpu id=0x%x\n", cpu_id);
+	rk_remotectl_parse_ir_keys(pdev);
+	tasklet_init(&ddata->remote_tasklet, rk_pwm_remotectl_do_something,
+		     (unsigned long)ddata);
+	for (j = 0; j < num; j++) {
+		DBG("remotectl probe j = 0x%x\n", j);
+		for (i = 0; i < remotectl_button[j].nbuttons; i++) {
+			int keycode;
+
+			keycode = remotectl_button[j].key_table[i].keycode;
+			input_set_capability(input, EV_KEY, keycode);
+		}
+	}
+	ret = input_register_device(input);
+	if (ret)
+		dev_err(&pdev->dev, "register input device err, ret=%d\n", ret);
+	input_set_capability(input, EV_KEY, KEY_WAKEUP);
+	device_init_wakeup(&pdev->dev, 1);
+	enable_irq_wake(irq);
+	timer_setup(&ddata->timer, rk_pwm_remotectl_timer, 0);
+	//ddata->remotectl_wake_lock = wakeup_source_create("rockchip_pwm_remote");
+	/*wakeup_source_init(&ddata->remotectl_wake_lock,
+		       WAKE_LOCK_SUSPEND, "rockchip_pwm_remote");*/
+	cpumask_clear(&cpumask);
+	cpumask_set_cpu(cpu_id, &cpumask);
+	irq_set_affinity(irq, &cpumask);
+	ret = devm_request_irq(&pdev->dev, irq, rockchip_pwm_irq,
+			       IRQF_NO_SUSPEND, "rk_pwm_irq", ddata);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot claim IRQ %d\n", irq);
+		goto error_irq;
+	}
+
+	pwm_freq = clk_get_rate(clk) / 64;
+	ddata->pwm_freq_nstime = 1000000000 / pwm_freq;
+	rk_pwm_remotectl_hw_init(ddata->base, pwm_id);
+
+	ret = rk_pwm_pwrkey_wakeup_init(pdev);
+	if (!ret) {
+		dev_info(&pdev->dev, "Controller support pwrkey capture\n");
+		goto end;
+	}
+
+	ret = rk_pwm_sip_wakeup_init(pdev);
+	if (ret)
+		dev_info(&pdev->dev, "Donot support ATF Wakeup\n");
+	else
+		dev_info(&pdev->dev, "Support ATF Wakeup\n");
+
+	led_trigger_register_simple("rk-remote-feedback", &led_feedback);
+
+	dev_info(&pdev->dev, "rk pwm remotectl init end!\n");
+end:
+	return 0;
+error_irq:
+	//wakeup_source_destroy(ddata->remotectl_wake_lock);
+error_pclk:
+	clk_unprepare(p_clk);
+error_clk:
+	clk_unprepare(clk);
+	return ret;
+}
+
+static int rk_pwm_remove(struct platform_device *pdev)
+{
+	led_trigger_unregister_simple(led_feedback);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int remotectl_suspend(struct device *dev)
+{
+	int cpu = 0;
+	int pwm_id;
+	struct cpumask cpumask;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct rkxx_remotectl_drvdata *ddata = platform_get_drvdata(pdev);
+
+	if (ddata->pwm_pwrkey_capture) {
+		pwm_id = ddata->remote_pwm_id;
+		ddata->pwrkey_wakeup = 0;
+		rk_pwm_int_ctrl(ddata->base, pwm_id, PWM_INT_DISABLE);
+	}
+	cpumask_clear(&cpumask);
+	cpumask_set_cpu(cpu, &cpumask);
+	irq_set_affinity(ddata->irq, &cpumask);
+	return 0;
+}
+
+
+static int remotectl_resume(struct device *dev)
+{
+	struct cpumask cpumask;
+	int pwm_id;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct rkxx_remotectl_drvdata *ddata = platform_get_drvdata(pdev);
+	struct arm_smccc_res res;
+	int state;
+
+	cpumask_clear(&cpumask);
+	cpumask_set_cpu(ddata->handle_cpu_id, &cpumask);
+	irq_set_affinity(ddata->irq, &cpumask);
+	if (ddata->support_psci) {
+		/*
+		 * loop wakeup state
+		 */
+        arm_smccc_smc(ROCKCHIP_SIP_REMOTECTL_CFG, REMOTECTL_GET_WAKEUP_STATE, 0, 0, 0, 0, 0, 0, &res);
+        state = res.a0;
+        /*
+		state = sip_smc_remotectl_config(
+					REMOTECTL_GET_WAKEUP_STATE, 0);*/
+		if (state == REMOTECTL_PWRKEY_WAKEUP)
+			rk_pwm_wakeup(ddata->input);
+	}  else if (ddata->pwm_pwrkey_capture) {
+		pwm_id = ddata->remote_pwm_id;
+		rk_pwm_int_ctrl(ddata->base, pwm_id, PWM_INT_ENABLE);
+		if (ddata->pwrkey_wakeup == 0)
+			return 0;
+		ddata->pwrkey_wakeup = 0;
+		rk_pwm_wakeup(ddata->input);
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops remotectl_pm_ops = {
+	.suspend_late = remotectl_suspend,
+	.resume_early = remotectl_resume,
+};
+#endif
+
+static const struct of_device_id rk_pwm_of_match[] = {
+	{ .compatible =  "rockchip,remotectl-pwm"},
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, rk_pwm_of_match);
+
+static struct platform_driver rk_pwm_driver = {
+	.driver = {
+		.name = "remotectl-pwm",
+		.of_match_table = rk_pwm_of_match,
+#ifdef CONFIG_PM
+		.pm = &remotectl_pm_ops,
+#endif
+	},
+	.remove = rk_pwm_remove,
+};
+
+module_platform_driver_probe(rk_pwm_driver, rk_pwm_probe);
+
+MODULE_LICENSE("GPL");
diff -ruPN linux/drivers/input/remotectl/rockchip_pwm_remotectl.h linux-new/drivers/input/remotectl/rockchip_pwm_remotectl.h
--- linux/drivers/input/remotectl/rockchip_pwm_remotectl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-new/drivers/input/remotectl/rockchip_pwm_remotectl.h	2022-04-15 11:13:41.131840776 +0200
@@ -0,0 +1,160 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef __RKXX_PWM_REMOTECTL_H__
+#define __RKXX_PWM_REMOTECTL_H__
+#include <linux/input.h>
+
+#define MAX_NUM_KEYS			60
+#define PWM_PWR_KEY_CAPURURE_MAX	10
+
+/* PWM0 registers  */
+#define PWM_REG_CNTR			0x00  /* Counter Register */
+#define PWM_REG_HPR			0x04  /* Period Register */
+#define PWM_REG_LPR			0x08  /* Duty Cycle Register */
+#define PWM_REG_CTRL			0x0c  /* Control Register */
+#define PWM3_REG_INTSTS			0x10  /* Interrupt Status Refister For Pwm3*/
+#define PWM2_REG_INTSTS			0x20  /* Interrupt Status Refister For Pwm2*/
+#define PWM1_REG_INTSTS			0x30  /* Interrupt Status Refister For Pwm1*/
+#define PWM0_REG_INTSTS			0x40  /* Interrupt Status Refister For Pwm0*/
+#define PWM3_REG_INT_EN			0x14  /* Interrupt Enable Refister For Pwm3*/
+#define PWM2_REG_INT_EN			0x24  /* Interrupt Enable Refister For Pwm2*/
+#define PWM1_REG_INT_EN			0x34  /* Interrupt Enable Refister For Pwm1*/
+#define PWM0_REG_INT_EN			0x44  /* Interrupt Enable Refister For Pwm0*/
+
+/*REG_CTRL bits definitions*/
+#define PWM_ENABLE			(1 << 0)
+#define PWM_DISABLE			(0 << 0)
+
+/*operation mode*/
+#define PWM_MODE_ONESHOT		(0x00 << 1)
+#define PWM_MODE_CONTINUMOUS		(0x01 << 1)
+#define PWM_MODE_CAPTURE		(0x02 << 1)
+
+/*duty cycle output polarity*/
+#define PWM_DUTY_POSTIVE		(0x01 << 3)
+#define PWM_DUTY_NEGATIVE		(0x00 << 3)
+
+/*incative state output polarity*/
+#define PWM_INACTIVE_POSTIVE		(0x01 << 4)
+#define PWM_INACTIVE_NEGATIVE		(0x00 << 4)
+
+/*clock source select*/
+#define PWM_CLK_SCALE			(1 << 9)
+#define PWM_CLK_NON_SCALE		(0 << 9)
+
+#define PWM_CH0_INT			(1 << 0)
+#define PWM_CH1_INT			(1 << 1)
+#define PWM_CH2_INT			(1 << 2)
+#define PWM_CH3_INT			(1 << 3)
+#define PWM_PWR_KEY_INT			(1 << 7)
+
+#define PWM_CH0_POL			(1 << 8)
+#define PWM_CH1_POL			(1 << 9)
+#define PWM_CH2_POL			(1 << 10)
+#define PWM_CH3_POL			(1 << 11)
+
+#define PWM_CH0_INT_ENABLE		(1 << 0)
+#define PWM_CH0_INT_DISABLE		(0 << 0)
+
+#define PWM_CH1_INT_ENABLE		(1 << 1)
+#define PWM_CH1_INT_DISABLE		(0 << 1)
+
+#define PWM_CH2_INT_ENABLE		(1 << 2)
+#define PWM_CH2_INT_DISABLE		(0 << 2)
+
+#define PWM_CH3_INT_ENABLE		(1 << 3)
+#define PWM_CH3_INT_DISABLE		(0 << 3)
+
+#define PWM_INT_ENABLE			1
+#define PWM_INT_DISABLE			0
+
+/*prescale factor*/
+#define PWMCR_MIN_PRESCALE			0x00
+#define PWMCR_MAX_PRESCALE			0x07
+
+#define PWMDCR_MIN_DUTY				0x0001
+#define PWMDCR_MAX_DUTY				0xFFFF
+
+#define PWMPCR_MIN_PERIOD			0x0001
+#define PWMPCR_MAX_PERIOD			0xFFFF
+
+#define PWMPCR_MIN_PERIOD			0x0001
+#define PWMPCR_MAX_PERIOD			0xFFFF
+
+
+enum pwm_div {
+	PWM_DIV1	= (0x0 << 12),
+	PWM_DIV2	= (0x1 << 12),
+	PWM_DIV4	= (0x2 << 12),
+	PWM_DIV8	= (0x3 << 12),
+	PWM_DIV16	= (0x4 << 12),
+	PWM_DIV32	= (0x5 << 12),
+	PWM_DIV64	= (0x6 << 12),
+	PWM_DIV128	= (0x7 << 12),
+};
+
+/*  NEC Protocol */
+#define RK_PWM_TIME_PRE_MIN		4000
+#define RK_PWM_TIME_PRE_MAX		5000
+
+#define RK_PWM_TIME_PRE_MIN_LOW		8000
+#define RK_PWM_TIME_PRE_MAX_LOW		10000
+
+#define RK_PWM_TIME_BIT0_MIN		390
+#define RK_PWM_TIME_BIT0_MAX		730
+
+#define RK_PWM_TIME_BIT1_MIN		1300
+#define RK_PWM_TIME_BIT1_MAX		2000
+
+#define RK_PWM_TIME_BIT_MIN_LOW		390
+#define RK_PWM_TIME_BIT_MAX_LOW		730
+
+#define RK_PWM_TIME_RPT_MIN		2000
+#define RK_PWM_TIME_RPT_MAX		2500
+
+#define RK_PWM_TIME_SEQ1_MIN		95000
+#define RK_PWM_TIME_SEQ1_MAX		98000
+
+#define RK_PWM_TIME_SEQ2_MIN		30000
+#define RK_PWM_TIME_SEQ2_MAX		55000
+
+
+#define PWM_REG_INTSTS(n)		((3 - (n)) * 0x10 + 0x10)
+#define PWM_REG_INT_EN(n)		((3 - (n)) * 0x10 + 0x14)
+#define RK_PWM_VERSION_ID(n)		((3 - (n)) * 0x10 + 0x2c)
+#define PWM_REG_PWRMATCH_CTRL(n)	((3 - (n)) * 0x10 + 0x50)
+#define PWM_REG_PWRMATCH_LPRE(n)	((3 - (n)) * 0x10 + 0x54)
+#define PWM_REG_PWRMATCH_HPRE(n)	((3 - (n)) * 0x10 + 0x58)
+#define PWM_REG_PWRMATCH_LD(n)		((3 - (n)) * 0x10 + 0x5C)
+#define PWM_REG_PWRMATCH_HD_ZERO(n)	((3 - (n)) * 0x10 + 0x60)
+#define PWM_REG_PWRMATCH_HD_ONE(n)	((3 - (n)) * 0x10 + 0x64)
+#define PWM_PWRMATCH_VALUE(n)		((3 - (n)) * 0x10 + 0x68)
+#define PWM_PWRCAPTURE_VALUE(n)		((3 - (n)) * 0x10 + 0x9c)
+
+#define PWM_CH_INT(n)			BIT(n)
+#define PWM_CH_POL(n)			BIT(n+8)
+
+#define PWM_CH_INT_ENABLE(n)		BIT(n)
+#define PWM_PWR_INT_ENABLE		BIT(7)
+#define CH3_PWRKEY_ENABLE		BIT(3)
+
+
+
+
+typedef enum _RMC_STATE {
+	RMC_IDLE,
+	RMC_PRELOAD,
+	RMC_USERCODE,
+	RMC_GETDATA,
+	RMC_SEQUENCE,
+} eRMC_STATE;
+
+
+struct RKxx_remotectl_platform_data {
+	int nbuttons;
+	int rep;
+	int timer;
+	int wakeup;
+};
+
+#endif
diff -ruPN linux/drivers/soc/rockchip/Makefile linux-new/drivers/soc/rockchip/Makefile
--- linux/drivers/soc/rockchip/Makefile	2022-04-13 21:01:11.000000000 +0200
+++ linux-new/drivers/soc/rockchip/Makefile	2022-04-15 11:13:41.131840776 +0200
@@ -5,3 +5,5 @@
 obj-$(CONFIG_ROCKCHIP_GRF) += grf.o
 obj-$(CONFIG_ROCKCHIP_IODOMAIN) += io-domain.o
 obj-$(CONFIG_ROCKCHIP_PM_DOMAINS) += pm_domains.o
+obj-y += rockchip_pm_config.o
+
diff -ruPN linux/drivers/soc/rockchip/rockchip_pm_config.c linux-new/drivers/soc/rockchip/rockchip_pm_config.c
--- linux/drivers/soc/rockchip/rockchip_pm_config.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-new/drivers/soc/rockchip/rockchip_pm_config.c	2022-04-15 11:13:41.132840776 +0200
@@ -0,0 +1,191 @@
+/*
+ * Rockchip Generic power configuration support.
+ *
+ * Copyright (c) 2017 ROCKCHIP, Co. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/arm-smccc.h>
+#include <linux/bitops.h>
+#include <linux/cpu.h>
+#include <linux/module.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <uapi/linux/psci.h>
+#include <linux/suspend.h>
+#include <dt-bindings/input/input.h>
+#include <soc/rockchip/rockchip_sip.h>
+
+#define PM_INVALID_GPIO			0xffff
+#define MAX_ON_OFF_REG_NUM		30
+#define MAX_ON_OFF_REG_PROP_NAME_LEN	60
+
+#define PSCI_FN_NATIVE(version, name)	PSCI_##version##_FN_##name
+
+enum rk_pm_state {
+	RK_PM_MEM = 0,
+	RK_PM_MEM_LITE,
+	RK_PM_MEM_ULTRA,
+	RK_PM_STATE_MAX
+};
+
+static const struct of_device_id pm_match_table[] = {
+	{ .compatible = "rockchip,pm-px30",},
+	{ .compatible = "rockchip,pm-rk1808",},
+	{ .compatible = "rockchip,pm-rk322x",},
+	{ .compatible = "rockchip,pm-rk3288",},
+	{ .compatible = "rockchip,pm-rk3308",},
+	{ .compatible = "rockchip,pm-rk3328",},
+	{ .compatible = "rockchip,pm-rk3368",},
+	{ .compatible = "rockchip,pm-rk3399",},
+	{ .compatible = "rockchip,pm-rk3568",},
+	{ .compatible = "rockchip,pm-rv1126",},
+	{ },
+};
+
+static void rockchip_pm_virt_pwroff_prepare(void)
+{
+    struct arm_smccc_res res;
+	int error;
+
+	regulator_suspend_prepare(PM_SUSPEND_MEM);
+
+	error = freeze_secondary_cpus(0);
+	if (error) {
+		pr_err("Disable nonboot cpus failed!\n");
+		return;
+	}
+
+    //sip_smc_set_suspend_mode(VIRTUAL_POWEROFF, 0, 1);
+	arm_smccc_smc(ROCKCHIP_SIP_SUSPEND_MODE, ROCKCHIP_VIRTUAL_POWEROFF, 0, 1, 0, 0, 0, 0, &res);
+	//sip_smc_virtual_poweroff();
+	arm_smccc_smc(PSCI_FN_NATIVE(1_0, SYSTEM_SUSPEND), 0, 0, 0, 0, 0, 0, 0, &res);
+}
+
+static int pm_config_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *match_id;
+	struct device_node *node;
+    struct arm_smccc_res res;
+	u32 mode_config = 0;
+	u32 wakeup_config = 0;
+	u32 pwm_regulator_config = 0;
+	int gpio_temp[10];
+	u32 sleep_debug_en = 0;
+	u32 apios_suspend = 0;
+	u32 virtual_poweroff_en = 0;
+	enum of_gpio_flags flags;
+	int i = 0;
+	int length;
+
+	match_id = of_match_node(pm_match_table, pdev->dev.of_node);
+	if (!match_id)
+		return -ENODEV;
+
+	node = of_find_node_by_name(NULL, "rockchip-suspend");
+
+	if (IS_ERR_OR_NULL(node)) {
+		dev_err(&pdev->dev, "%s dev node err\n",  __func__);
+		return -ENODEV;
+	}
+
+    arm_smccc_smc(ROCKCHIP_SIP_SIP_VERSION, ROCKCHIP_SIP_IMPLEMENT_V2, SECURE_REG_WR, 0, 0, 0, 0, 0, &res);
+
+    if (res.a0) {
+        dev_err(&pdev->dev,"%s: set rockchip sip version v2 failed\n", __func__);
+        return -1;
+    }
+
+    dev_info(&pdev->dev,"Rockchip SIP initialized, for power off version 0x%lx\n", res.a1);
+
+	if (of_property_read_u32_array(node,
+				       "rockchip,sleep-mode-config",
+				       &mode_config, 1))
+		dev_warn(&pdev->dev, "not set sleep mode config\n");
+	else
+		arm_smccc_smc(ROCKCHIP_SIP_SUSPEND_MODE, ROCKCHIP_SUSPEND_MODE_CONFIG, mode_config, 0, 0, 0, 0, 0, &res);
+        //sip_smc_set_suspend_mode(SUSPEND_MODE_CONFIG, mode_config, 0);
+
+	if (of_property_read_u32_array(node,
+				       "rockchip,wakeup-config",
+				       &wakeup_config, 1))
+		dev_warn(&pdev->dev, "not set wakeup-config\n");
+	else
+        arm_smccc_smc(ROCKCHIP_SIP_SUSPEND_MODE, ROCKCHIP_WKUP_SOURCE_CONFIG, wakeup_config, 0, 0, 0, 0, 0, &res);
+		//sip_smc_set_suspend_mode(WKUP_SOURCE_CONFIG, wakeup_config, 0);
+
+	if (of_property_read_u32_array(node,
+				       "rockchip,pwm-regulator-config",
+				       &pwm_regulator_config, 1))
+		dev_warn(&pdev->dev, "not set pwm-regulator-config\n");
+	else
+        arm_smccc_smc(ROCKCHIP_SIP_SUSPEND_MODE, ROCKCHIP_PWM_REGULATOR_CONFIG, pwm_regulator_config, 0, 0, 0, 0, 0, &res);
+		/*sip_smc_set_suspend_mode(PWM_REGULATOR_CONFIG,
+					 pwm_regulator_config,
+					 0);*/
+
+	length = of_gpio_named_count(node, "rockchip,power-ctrl");
+
+	if (length > 0 && length < 10) {
+		for (i = 0; i < length; i++) {
+			gpio_temp[i] = of_get_named_gpio_flags(node,
+							     "rockchip,power-ctrl",
+							     i,
+							     &flags);
+			if (!gpio_is_valid(gpio_temp[i]))
+				break;
+            arm_smccc_smc(ROCKCHIP_SIP_SUSPEND_MODE, ROCKCHIP_GPIO_POWER_CONFIG, i, gpio_temp[i], 0, 0, 0, 0, &res);
+			/*sip_smc_set_suspend_mode(GPIO_POWER_CONFIG,
+						 i,
+						 gpio_temp[i]);*/
+		}
+	}
+	arm_smccc_smc(ROCKCHIP_SIP_SUSPEND_MODE, ROCKCHIP_GPIO_POWER_CONFIG, i, PM_INVALID_GPIO, 0, 0, 0, 0, &res);
+	//sip_smc_set_suspend_mode(GPIO_POWER_CONFIG, i, PM_INVALID_GPIO);
+
+	if (!of_property_read_u32_array(node,
+					"rockchip,sleep-debug-en",
+					&sleep_debug_en, 1))
+        arm_smccc_smc(ROCKCHIP_SIP_SUSPEND_MODE, ROCKCHIP_SUSPEND_DEBUG_ENABLE, sleep_debug_en, 0, 0, 0, 0, 0, &res);
+		/*sip_smc_set_suspend_mode(SUSPEND_DEBUG_ENABLE,
+					 sleep_debug_en,
+					 0);*/
+
+	if (!of_property_read_u32_array(node,
+					"rockchip,apios-suspend",
+					&apios_suspend, 1))
+        arm_smccc_smc(ROCKCHIP_SIP_SUSPEND_MODE, ROCKCHIP_APIOS_SUSPEND_CONFIG, apios_suspend, 0, 0, 0, 0, 0, &res);
+		/*sip_smc_set_suspend_mode(APIOS_SUSPEND_CONFIG,
+					 apios_suspend,
+					 0);*/
+
+	if (!of_property_read_u32_array(node,
+					"rockchip,virtual-poweroff",
+					&virtual_poweroff_en, 1) &&
+	    virtual_poweroff_en)
+		pm_power_off_prepare = rockchip_pm_virt_pwroff_prepare;
+
+	return 0;
+}
+
+static struct platform_driver pm_driver = {
+	.probe = pm_config_probe,
+	.driver = {
+		.name = "rockchip-pm",
+		.of_match_table = pm_match_table
+	},
+};
+
+static int __init rockchip_pm_drv_register(void)
+{
+	return platform_driver_register(&pm_driver);
+}
+late_initcall_sync(rockchip_pm_drv_register);
+MODULE_DESCRIPTION("Rockchip suspend mode config");
+MODULE_LICENSE("GPL");
diff -ruPN linux/include/dt-bindings/suspend/rockchip-px30.h linux-new/include/dt-bindings/suspend/rockchip-px30.h
--- linux/include/dt-bindings/suspend/rockchip-px30.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-new/include/dt-bindings/suspend/rockchip-px30.h	2022-04-15 11:13:41.132840776 +0200
@@ -0,0 +1,53 @@
+/*
+ * Header providing constants for Rockchip suspend bindings.
+ *
+ * Copyright (C) 2017, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: XiaoDong.Huang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __DT_BINDINGS_ROCKCHIP_PM_H__
+#define __DT_BINDINGS_ROCKCHIP_PM_H__
+/******************************bits ops************************************/
+
+#ifndef BIT
+#define BIT(nr)				(1 << (nr))
+#endif
+
+#define RKPM_SLP_ARMPD			BIT(0)
+#define RKPM_SLP_ARMOFF			BIT(1)
+#define RKPM_SLP_ARMOFF_DDRPD		BIT(2)
+#define RKPM_SLP_ARMOFF_LOGOFF		BIT(3)
+
+/* all plls except ddr's pll*/
+#define RKPM_SLP_PMU_HW_PLLS_PD		BIT(8)
+#define RKPM_SLP_PMU_PMUALIVE_32K	BIT(9)
+#define RKPM_SLP_PMU_DIS_OSC		BIT(10)
+
+#define RKPM_SLP_CLK_GT			BIT(16)
+#define RKPM_SLP_PMIC_LP		BIT(17)
+
+#define RKPM_SLP_32K_EXT		BIT(24)
+#define RKPM_SLP_TIME_OUT_WKUP		BIT(25)
+#define RKPM_SLP_PMU_DBG		BIT(26)
+
+/* the wake up source */
+#define RKPM_CLUSTER_WKUP_EN		BIT(0)
+#define RKPM_GPIO_WKUP_EN		BIT(2)
+#define RKPM_SDIO_WKUP_EN		BIT(3)
+#define RKPM_SDMMC_WKUP_EN		BIT(4)
+#define RKPM_UART0_WKUP_EN		BIT(5)
+#define RKPM_TIMER_WKUP_EN		BIT(6)
+#define RKPM_USB_WKUP_EN		BIT(7)
+#define RKPM_SFT_WKUP_EN		BIT(8)
+#define RKPM_TIME_OUT_WKUP_EN		BIT(10)
+
+#endif
diff -ruPN linux/include/dt-bindings/suspend/rockchip-rk1808.h linux-new/include/dt-bindings/suspend/rockchip-rk1808.h
--- linux/include/dt-bindings/suspend/rockchip-rk1808.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-new/include/dt-bindings/suspend/rockchip-rk1808.h	2022-04-15 11:13:41.132840776 +0200
@@ -0,0 +1,46 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Header providing constants for Rockchip suspend bindings.
+ *
+ * Copyright (C) 2018, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: XiaoDong.Huang
+ */
+
+#ifndef __DT_BINDINGS_RK1808_PM_H__
+#define __DT_BINDINGS_RK1808_PM_H__
+/******************************bits ops************************************/
+
+#ifndef BIT
+#define BIT(nr)				(1 << (nr))
+#endif
+
+#define RKPM_SLP_ARMPD			BIT(0)
+#define RKPM_SLP_ARMOFF			BIT(1)
+#define RKPM_SLP_ARMOFF_DDRPD		BIT(2)
+#define RKPM_SLP_ARMOFF_LOGOFF		BIT(3)
+
+/* all plls except ddr's pll*/
+#define RKPM_SLP_PMU_HW_PLLS_PD		BIT(8)
+#define RKPM_SLP_PMU_PMUALIVE_32K	BIT(9)
+#define RKPM_SLP_PMU_DIS_OSC		BIT(10)
+
+#define RKPM_SLP_CLK_GT			BIT(16)
+#define RKPM_SLP_PMIC_LP		BIT(17)
+
+#define RKPM_SLP_32K_EXT		BIT(24)
+#define RKPM_SLP_TIME_OUT_WKUP		BIT(25)
+#define RKPM_SLP_PMU_DBG		BIT(26)
+
+/* the wake up source */
+#define RKPM_CLUSTER_WKUP_EN		BIT(0)
+#define RKPM_GPIO_WKUP_EN		BIT(2)
+#define RKPM_SDIO_WKUP_EN		BIT(3)
+#define RKPM_SDMMC_WKUP_EN		BIT(4)
+#define RKPM_UART0_WKUP_EN		BIT(5)
+#define RKPM_TIMER_WKUP_EN		BIT(6)
+#define RKPM_USB_WKUP_EN		BIT(7)
+#define RKPM_SFT_WKUP_EN		BIT(8)
+#define RKPM_VAD_WKUP_EN		BIT(9)
+#define RKPM_TIME_OUT_WKUP_EN		BIT(10)
+
+#endif
diff -ruPN linux/include/dt-bindings/suspend/rockchip-rk322x.h linux-new/include/dt-bindings/suspend/rockchip-rk322x.h
--- linux/include/dt-bindings/suspend/rockchip-rk322x.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-new/include/dt-bindings/suspend/rockchip-rk322x.h	2022-04-15 11:13:41.132840776 +0200
@@ -0,0 +1,57 @@
+/*
+ * Header providing constants for Rockchip suspend bindings.
+ *
+ * Copyright (C) 2017, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: XiaoDong.Huang
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __DT_BINDINGS_SUSPEND_ROCKCHIP_RK322X_H__
+#define __DT_BINDINGS_SUSPEND_ROCKCHIP_RK322X_H__
+
+#ifndef BIT
+#define BIT(nr)				(1 << (nr))
+#endif
+
+/* the suspend mode */
+#define RKPM_CTR_PWR_DMNS		BIT(0)
+#define RKPM_CTR_GTCLKS			BIT(1)
+#define RKPM_CTR_PLLS			BIT(2)
+#define RKPM_CTR_VOLTS			BIT(3)
+#define RKPM_CTR_GPIOS			BIT(4)
+#define RKPM_CTR_DDR			BIT(5)
+#define RKPM_CTR_PMIC			BIT(6)
+
+/* system clk is 24M,and div to min */
+#define RKPM_CTR_SYSCLK_DIV		BIT(7)
+/* switch sysclk to 32k, need hardwart support, and div to min */
+#define RKPM_CTR_SYSCLK_32K		BIT(8)
+/* switch sysclk to 32k,disable 24M OSC,
+ * need hardwart susport. and div to min
+ */
+#define RKPM_CTR_SYSCLK_OSC_DIS		BIT(9)
+#define RKPM_CTR_VOL_PWM0		BIT(10)
+#define RKPM_CTR_VOL_PWM1		BIT(11)
+#define RKPM_CTR_VOL_PWM2		BIT(12)
+#define RKPM_CTR_VOL_PWM3		BIT(13)
+#define RKPM_CTR_BUS_IDLE		BIT(14)
+#define RKPM_CTR_SRAM			BIT(15)
+/*Low Power Function Selection*/
+#define RKPM_CTR_IDLESRAM_MD		BIT(16)
+#define RKPM_CTR_IDLEAUTO_MD		BIT(17)
+#define RKPM_CTR_ARMDP_LPMD		BIT(18)
+#define RKPM_CTR_ARMOFF_LPMD		BIT(19)
+#define RKPM_CTR_ARMLOGDP_LPMD		BIT(20)
+#define RKPM_CTR_ARMOFF_LOGDP_LPMD	BIT(21)
+#define RKPM_CTR_ARMLOGOFF_DLPMD	BIT(22)
+
+#endif
diff -ruPN linux/include/dt-bindings/suspend/rockchip-rk3288.h linux-new/include/dt-bindings/suspend/rockchip-rk3288.h
--- linux/include/dt-bindings/suspend/rockchip-rk3288.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-new/include/dt-bindings/suspend/rockchip-rk3288.h	2022-04-15 11:13:41.132840776 +0200
@@ -0,0 +1,59 @@
+/*
+ * Header providing constants for Rockchip suspend bindings.
+ *
+ * Copyright (C) 2017, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: Power.xu
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __DT_BINDINGS_SUSPEND_ROCKCHIP_RK3288_H__
+#define __DT_BINDINGS_SUSPEND_ROCKCHIP_RK3288_H__
+
+/* the suspend mode */
+#define	RKPM_CTR_PWR_DMNS		(1 << 0)
+#define RKPM_CTR_GTCLKS			(1 << 1)
+#define RKPM_CTR_PLLS			(1 << 2)
+#define RKPM_CTR_VOLTS			(1 << 3)
+#define RKPM_CTR_GPIOS			(1 << 4)
+#define RKPM_CTR_DDR			(1 << 5)
+#define RKPM_CTR_PMIC			(1 << 6)
+/* system clk is 24M,and div to min */
+#define RKPM_CTR_SYSCLK_DIV		(1 << 7)
+/* switch sysclk to 32k, need hardwart support, and div to min */
+#define RKPM_CTR_SYSCLK_32K		(1 << 8)
+/* switch sysclk to 32k,disable 24M OSC,
+ * need hardwart susport. and div to min
+ */
+#define RKPM_CTR_SYSCLK_OSC_DIS		(1 << 9)
+#define RKPM_CTR_BUS_IDLE		(1 << 14)
+#define RKPM_CTR_SRAM			(1 << 15)
+/*Low Power Function Selection*/
+#define RKPM_CTR_IDLESRAM_MD		(1 << 16)
+#define RKPM_CTR_IDLEAUTO_MD		(1 << 17)
+#define RKPM_CTR_ARMDP_LPMD		(1 << 18)
+#define RKPM_CTR_ARMOFF_LPMD		(1 << 19)
+#define RKPM_CTR_ARMLOGDP_LPMD		(1 << 20)
+#define RKPM_CTR_ARMOFF_LOGDP_LPMD	(1 << 21)
+#define RKPM_CTR_ARMLOGOFF_DLPMD	(1 << 22)
+
+/* the wake up source */
+#define RKPM_ARMINT_WKUP_EN		(1 << 0)
+#define RKPM_SDMMC_WKUP_EN		(1 << 2)
+#define RKPM_GPIO_WKUP_EN		(1 << 3)
+
+/* the pwm regulator */
+#define PWM0_REGULATOR_EN		(1 << 0)
+#define PWM1_REGULATOR_EN		(1 << 1)
+#define PWM2_REGULATOR_EN		(1 << 2)
+#define PWM3_REGULATOR_EN		(1 << 3)
+
+#endif
diff -ruPN linux/include/dt-bindings/suspend/rockchip-rk3308.h linux-new/include/dt-bindings/suspend/rockchip-rk3308.h
--- linux/include/dt-bindings/suspend/rockchip-rk3308.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-new/include/dt-bindings/suspend/rockchip-rk3308.h	2022-04-15 11:13:41.132840776 +0200
@@ -0,0 +1,104 @@
+/*
+ * Header providing constants for Rockchip suspend bindings.
+ *
+ * Copyright (C) 2018, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: Joseph Chen
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __DT_BINDINGS_RK3308_PM_H__
+#define __DT_BINDINGS_RK3308_PM_H__
+/******************************bits ops************************************/
+
+#ifndef BIT
+#define BIT(nr)				(1 << (nr))
+#endif
+
+/*
+ *	RK3308 system suspend mode configure definitions.
+ *
+ * Driver:
+ *	These configures are pass to ATF by SMC in:
+ *	drivers/soc/rockchip/rockchip_pm_config.c
+ *
+ * DTS:
+ *	rockchip_suspend: rockchip-suspend {
+ *		rockchip,sleep-mode-config = <...>;
+ *		rockchip,wakeup-config = <...>;
+ *		rockchip,apios-suspend = <...>;
+ *		rockchip,pwm-regulator-config = <...>;
+ *	};
+ */
+
+/*
+ * Suspend mode:
+ *	rockchip,sleep-mode-config = <...>;
+ */
+#define RKPM_ARMOFF			BIT(0)	/* vdd_arm off */
+#define RKPM_VADOFF			BIT(1)	/* assume vad off, enter lowest system suspend */
+#define RKPM_PMU_HW_PLLS_PD		BIT(3)	/* disable PLLs by PMU hardware, recommend */
+#define RKPM_PMU_DIS_OSC		BIT(4)	/* disable 24M osc */
+#define RKPM_PMU_PMUALIVE_32K		BIT(5)	/* pvtm 32khz */
+#define RKPM_PMU_EXT_32K		BIT(6)	/* ext 32khz osc */
+#define RKPM_DDR_SREF_HARDWARE		BIT(7)	/* ddr enter self-refresh by PMU hardware, not recommend */
+#define RKPM_DDR_EXIT_SRPD_IDLE		BIT(8)	/* ddr exit sr/pd idle by ddr controller,  not recommend */
+#define RKPM_PDM_CLK_OFF		BIT(9)	/* armoff with pdm clk off, not recommend */
+#define RKPM_PWM_VOLTAGE_DEFAULT	BIT(10) /* pwm regulator default voltage (same with maskrom) */
+
+/*
+ * Regulator mode:
+ *	rockchip,pwm-regulator-config = <...>;
+ */
+#define RKPM_PWM_REGULATOR		BIT(2)	/* support pwm regulator */
+
+/*
+ * Wakeup source:
+ *	rockchip,wakeup-config = <...>;
+ */
+#define RKPM_ARM_PRE_WAKEUP_EN		BIT(11)	/* all interrupts can wakeup(gic doesn't filter these) */
+#define RKPM_ARM_GIC_WAKEUP_EN		BIT(12)	/* all interrupts can wakeup(gic filter these) */
+#define RKPM_SDMMC_WAKEUP_EN		BIT(13)	/* sdmmc can wakeup */
+#define RKPM_SDMMC_GRF_IRQ_WAKEUP_EN	BIT(14)	/* sdmmc grf irq can wakeup */
+#define RKPM_TIMER_WAKEUP_EN		BIT(15)	/* rk timers can wakeup */
+#define RKPM_USBDEV_WAKEUP_EN		BIT(16)	/* usbdev can wakeup */
+#define RKPM_TIMEOUT_WAKEUP_EN		BIT(17)	/* PMU timeout can wakeup, for self test */
+#define RKPM_GPIO0_WAKEUP_EN		BIT(18)	/* gpio0(only) can wakeup */
+#define RKPM_VAD_WAKEUP_EN		BIT(19)	/* vad can wakeup */
+
+/*
+ * Debug control in system suspend:
+ *	rockchip,sleep-mode-config = <...>;
+ */
+#define RKPM_DBG_INT_TIMER_TEST		BIT(22)	/* enable RKPM_TIMEOUT_WAKEUP_EN */
+#define RKPM_DBG_WOARKAROUND		BIT(23)	/* ignore, useless */
+#define RKPM_DBG_VAD_INT_OFF		BIT(24)	/* enable RKPM_VADOFF */
+#define RKPM_DBG_CLK_UNGATE		BIT(25)	/* enable all clks */
+#define RKPM_DBG_CLKOUT			BIT(26) /* enable test_out clk output */
+#define RKPM_DBG_FSM_SOUT		BIT(27)	/* FSM state one pin out */
+#define RKPM_DBG_FSM_STATE		BIT(28)	/* FSM state multi pins out */
+#define RKPM_DBG_REG			BIT(29)	/* verbose regs */
+#define RKPM_DBG_VERBOSE		BIT(30)	/* verbose more message */
+#define RKPM_CONFIG_WAKEUP_END		BIT(31)	/* ignore, it's a placeholder */
+
+/*
+ * GPIOn/PWMn ignore global 1st reset, usually used for pwr_hold pin:
+ *	rockchip,apios-suspend = <...>;
+ */
+#define GLB1RST_IGNORE_PWM0		BIT(23)	/* pwm0 ignore global 1st reset */
+#define GLB1RST_IGNORE_PWM1		BIT(24)	/* pwm1 ignore global 1st reset */
+#define GLB1RST_IGNORE_PWM2		BIT(25)	/* pwm2 ignore global 1st reset */
+#define GLB1RST_IGNORE_GPIO0		BIT(26)	/* gpio0 ignore global 1st reset */
+#define GLB1RST_IGNORE_GPIO1		BIT(27)	/* gpio1 ignore global 1st reset */
+#define GLB1RST_IGNORE_GPIO2		BIT(28)	/* gpio2 ignore global 1st reset */
+#define GLB1RST_IGNORE_GPIO3		BIT(29)	/* gpio3 ignore global 1st reset */
+#define GLB1RST_IGNORE_GPIO4		BIT(30)	/* gpio4 ignore global 1st reset */
+
+#endif
diff -ruPN linux/include/dt-bindings/suspend/rockchip-rk3328.h linux-new/include/dt-bindings/suspend/rockchip-rk3328.h
--- linux/include/dt-bindings/suspend/rockchip-rk3328.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-new/include/dt-bindings/suspend/rockchip-rk3328.h	2022-04-15 11:13:41.132840776 +0200
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Header providing constants for Rockchip suspend bindings.
+ *
+ * Copyright (C) 2018, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: XiaoDong.Huang
+ */
+#ifndef __DT_BINDINGS_ROCKCHIP_PM_H__
+#define __DT_BINDINGS_ROCKCHIP_PM_H__
+/******************************bits ops************************************/
+
+#ifndef BIT
+#define BIT(nr)				(1 << (nr))
+#endif
+
+#define RKPM_SLP_CTR_VOL_PWM0		BIT(10)
+#define RKPM_SLP_CTR_VOL_PWM1		BIT(11)
+
+#endif
diff -ruPN linux/include/dt-bindings/suspend/rockchip-rk3368.h linux-new/include/dt-bindings/suspend/rockchip-rk3368.h
--- linux/include/dt-bindings/suspend/rockchip-rk3368.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-new/include/dt-bindings/suspend/rockchip-rk3368.h	2022-04-15 11:13:41.132840776 +0200
@@ -0,0 +1,56 @@
+/*
+ * Header providing constants for Rockchip suspend bindings.
+ *
+ * Copyright (C) 2015, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: Tony.Xie
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __DT_BINDINGS_ROCKCHIP_PM_H__
+#define __DT_BINDINGS_ROCKCHIP_PM_H__
+/******************************bits ops************************************/
+
+#ifndef BIT
+#define BIT(nr)				(1 << (nr))
+#endif
+
+#define RKPM_SLP_WFI			BIT(0)
+#define RKPM_SLP_ARMPD			BIT(1)
+#define RKPM_SLP_ARMOFF			BIT(2)
+#define RKPM_SLP_ARMOFF_LOGPD		BIT(3)
+#define RKPM_SLP_ARMOFF_LOGOFF		BIT(4)
+#define RKPM_RUNNING_ARMMODE		BIT(5)
+
+/* func ctrl by pmu auto ctr */
+#define RKPM_SLP_PMU_PLLS_PWRDN		BIT(8) /* all plls except ddr's pll*/
+#define RKPM_SLP_PMU_PMUALIVE_32K	BIT(9)
+#define RKPM_SLP_PMU_DIS_OSC		BIT(10)
+
+/* func ctrl by software set */
+#define RKPM_SLP_SFT_PLLS_DEEP		BIT(16) /* all plls except ddr's pll*/
+#define RKPM_SLP_SFT_32K_EXT		BIT(17)
+#define RKPM_SLP_SFT_PD_PERI		BIT(18)
+#define RKPM_SLP_SFT_PD_NBSCUS		BIT(19) /* noboot scus in muti-cluster */
+
+/* the wake up source */
+#define RKPM_CLUSTER_L_WKUP_EN		BIT(0)
+#define RKPM_CLUSTER_B_WKUPB_EN		BIT(1)
+#define RKPM_GPIO_WKUP_EN		BIT(2)
+#define RKPM_SDIO_WKUP_EN		BIT(3)
+#define RKPM_SDMMC_WKUP_EN		BIT(4)
+#define RKPM_SIM_WKUP_EN		BIT(5)
+#define RKPM_TIMER_WKUP_EN		BIT(6)
+#define RKPM_USB_WKUP_EN		BIT(7)
+#define RKPM_SFT_WKUP_EN		BIT(8)
+#define RKPM_WDT_M0_WKUP_EN		BIT(9)
+#define RKPM_TIME_OUT_WKUP_EN		BIT(10)
+
+#endif
diff -ruPN linux/include/dt-bindings/suspend/rockchip-rk3399.h linux-new/include/dt-bindings/suspend/rockchip-rk3399.h
--- linux/include/dt-bindings/suspend/rockchip-rk3399.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-new/include/dt-bindings/suspend/rockchip-rk3399.h	2022-04-15 11:13:41.133840776 +0200
@@ -0,0 +1,61 @@
+/*
+ * Header providing constants for Rockchip suspend bindings.
+ *
+ * Copyright (C) 2017, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: Tony.Xie
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __DT_BINDINGS_SUSPEND_ROCKCHIP_RK3399_H__
+#define __DT_BINDINGS_SUSPEND_ROCKCHIP_RK3399_H__
+
+/* the suspend mode */
+#define RKPM_SLP_WFI				(1 << 0)
+#define RKPM_SLP_ARMPD				(1 << 1)
+#define RKPM_SLP_PERILPPD			(1 << 2)
+#define RKPM_SLP_DDR_RET			(1 << 3)
+#define RKPM_SLP_PLLPD				(1 << 4)
+#define RKPM_SLP_OSC_DIS			(1 << 5)
+#define RKPM_SLP_CENTER_PD			(1 << 6)
+#define RKPM_SLP_AP_PWROFF			(1 << 7)
+
+/* the wake up source */
+#define RKPM_CLUSTER_L_WKUP_EN			(1 << 0)
+#define RKPM_CLUSTER_B_WKUPB_EN			(1 << 1)
+#define RKPM_GPIO_WKUP_EN			(1 << 2)
+#define RKPM_SDIO_WKUP_EN			(1 << 3)
+#define RKPM_SDMMC_WKUP_EN			(1 << 4)
+#define RKPM_TIMER_WKUP_EN			(1 << 6)
+#define RKPM_USB_WKUP_EN			(1 << 7)
+#define RKPM_SFT_WKUP_EN			(1 << 8)
+#define RKPM_WDT_M0_WKUP_EN			(1 << 9)
+#define RKPM_TIME_OUT_WKUP_EN			(1 << 10)
+#define RKPM_PWM_WKUP_EN			(1 << 11)
+#define RKPM_PCIE_WKUP_EN			(1 << 13)
+#define RKPM_USB_LINESTATE_WKUP_EN		(1 << 14)
+
+/* the pwm regulator */
+#define PWM0_REGULATOR_EN			(1 << 0)
+#define PWM1_REGULATOR_EN			(1 << 1)
+#define PWM2_REGULATOR_EN			(1 << 2)
+#define PWM3A_REGULATOR_EN			(1 << 3)
+#define PWM3B_REGULATOR_EN			(1 << 4)
+
+/* the APIO voltage domain */
+#define RKPM_APIO0_SUSPEND			(1 << 0)
+#define RKPM_APIO1_SUSPEND			(1 << 1)
+#define RKPM_APIO2_SUSPEND			(1 << 2)
+#define RKPM_APIO3_SUSPEND			(1 << 3)
+#define RKPM_APIO4_SUSPEND			(1 << 4)
+#define RKPM_APIO5_SUSPEND			(1 << 5)
+
+#endif
diff -ruPN linux/include/dt-bindings/suspend/rockchip-rk3568.h linux-new/include/dt-bindings/suspend/rockchip-rk3568.h
--- linux/include/dt-bindings/suspend/rockchip-rk3568.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-new/include/dt-bindings/suspend/rockchip-rk3568.h	2022-04-15 11:13:41.133840776 +0200
@@ -0,0 +1,57 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Header providing constants for Rockchip suspend bindings.
+ *
+ * Copyright (C) 2021, Rockchip Electronics Co., Ltd.
+ * Author: XiaoDong.Huang
+ */
+
+#ifndef __DT_BINDINGS_SUSPEND_ROCKCHIP_RK3568_H__
+#define __DT_BINDINGS_SUSPEND_ROCKCHIP_RK3568_H__
+/******************************bits ops************************************/
+
+#ifndef BIT
+#define BIT(nr)				(1 << (nr))
+#endif
+
+#define RKPM_SLP_WFI			BIT(0)
+#define RKPM_SLP_ARMOFF			BIT(1)
+#define RKPM_SLP_CENTER_OFF		BIT(2)
+#define RKPM_SLP_ARMOFF_LOGOFF		BIT(3)
+#define RKPM_SLP_FROM_UBOOT		BIT(4)
+#define RKPM_SLP_PMIC_LP		BIT(5)
+#define RKPM_SLP_HW_PLLS_OFF		BIT(6)
+#define RKPM_SLP_PMUALIVE_32K		BIT(7)
+#define RKPM_SLP_OSC_DIS		BIT(8)
+#define RKPM_SLP_32K_EXT		BIT(9)
+#define RKPM_SLP_32K_PVTM		BIT(10)
+/* the wake up source */
+#define RKPM_CPU0_WKUP_EN		BIT(0)
+#define RKPM_CPU1_WKUP_EN		BIT(1)
+#define RKPM_CPU2_WKUP_EN		BIT(2)
+#define RKPM_CPU3_WKUP_EN		BIT(3)
+#define RKPM_GPIO_WKUP_EN		BIT(4)
+#define RKPM_UART0_WKUP_EN		BIT(5)
+#define RKPM_SDMMC0_WKUP_EN		BIT(6)
+#define RKPM_SDMMC1_WKUP_EN		BIT(7)
+#define RKPM_SDMMC2_WKUP_EN		BIT(8)
+#define RKPM_USB_WKUP_EN		BIT(9)
+#define RKPM_PCIE_WKUP_EN		BIT(10)
+#define RKPM_VAD_WKUP_EN		BIT(11)
+#define RKPM_TIMER_WKUP_EN		BIT(12)
+#define RKPM_PWM0_WKUP_EN		BIT(13)
+#define RKPM_TIMEOUT_WKUP_EN		BIT(14)
+#define RKPM_SFT_WKUP_EN		BIT(15)
+#define RKPM_USB_LINESTATE_WKUP_EN	BIT(16)
+
+#define RKPM_SLP_LDO1_ON		BIT(0)
+#define RKPM_SLP_LDO2_ON		BIT(1)
+#define RKPM_SLP_LDO3_ON		BIT(2)
+#define RKPM_SLP_LDO4_ON		BIT(3)
+#define RKPM_SLP_LDO5_ON		BIT(4)
+#define RKPM_SLP_LDO6_ON		BIT(5)
+#define RKPM_SLP_LDO7_ON		BIT(6)
+#define RKPM_SLP_LDO8_ON		BIT(7)
+#define RKPM_SLP_LDO9_ON		BIT(8)
+
+#endif
diff -ruPN linux/include/dt-bindings/suspend/rockchip-rv1126.h linux-new/include/dt-bindings/suspend/rockchip-rv1126.h
--- linux/include/dt-bindings/suspend/rockchip-rv1126.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-new/include/dt-bindings/suspend/rockchip-rv1126.h	2022-04-15 11:13:41.133840776 +0200
@@ -0,0 +1,46 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Header providing constants for Rockchip suspend bindings.
+ *
+ * Copyright (C) 2020, Fuzhou Rockchip Electronics Co., Ltd
+ * Author: XiaoDong.Huang
+ */
+
+#ifndef __DT_BINDINGS_RV1126_PM_H__
+#define __DT_BINDINGS_RV1126_PM_H__
+/******************************bits ops************************************/
+
+#ifndef BIT
+#define BIT(nr)				(1 << (nr))
+#endif
+
+#define RKPM_SLP_ARMPD			BIT(0)
+#define RKPM_SLP_ARMOFF			BIT(1)
+#define RKPM_SLP_ARMOFF_DDRPD		BIT(2)
+#define RKPM_SLP_ARMOFF_LOGOFF		BIT(3)
+
+/* all plls except ddr's pll*/
+#define RKPM_SLP_PMU_HW_PLLS_PD		BIT(8)
+#define RKPM_SLP_PMU_PMUALIVE_32K	BIT(9)
+#define RKPM_SLP_PMU_DIS_OSC		BIT(10)
+
+#define RKPM_SLP_CLK_GT			BIT(16)
+#define RKPM_SLP_PMIC_LP		BIT(17)
+
+#define RKPM_SLP_32K_EXT		BIT(24)
+#define RKPM_SLP_TIME_OUT_WKUP		BIT(25)
+#define RKPM_SLP_PMU_DBG		BIT(26)
+
+/* the wake up source */
+#define RKPM_CPU0_WKUP_EN		BIT(0)
+#define RKPM_CPU1_WKUP_EN		BIT(1)
+#define RKPM_CPU2_WKUP_EN		BIT(2)
+#define RKPM_CPU3_WKUP_EN		BIT(3)
+#define RKPM_GPIO_WKUP_EN		BIT(4)
+#define RKPM_SDMMC_WKUP_EN		BIT(5)
+#define RKPM_SDIO_WKUP_EN		BIT(6)
+#define RKPM_USB_WKUP_EN		BIT(7)
+#define RKPM_UART1_WKUP_EN		BIT(8)
+#define RKPM_SYSINT_WKUP_EN		BIT(9)
+#define RKPM_TIME_OUT_WKUP_EN		BIT(10)
+#endif
diff -ruPN linux/include/soc/rockchip/rockchip_sip.h linux-new/include/soc/rockchip/rockchip_sip.h
--- linux/include/soc/rockchip/rockchip_sip.h	2022-04-15 11:11:32.975835411 +0200
+++ linux-new/include/soc/rockchip/rockchip_sip.h	2022-04-15 11:13:41.133840776 +0200
@@ -6,6 +6,8 @@
 #ifndef __SOC_ROCKCHIP_SIP_H
 #define __SOC_ROCKCHIP_SIP_H
 
+#define REMOTECTL_PWRKEY_WAKEUP		0xdeadbeaf
+
 #define ROCKCHIP_SIP_ATF_VERSION		0x82000001
 #define ROCKCHIP_SIP_DRAM_FREQ			0x82000008
 #define ROCKCHIP_SIP_CONFIG_DRAM_INIT		0x00
@@ -33,6 +35,22 @@
 #define SECURE_REG_RD			0x0
 #define SECURE_REG_WR			0x1
 
+#define ROCKCHIP_SIP_SUSPEND_MODE		0x82000003
+#define ROCKCHIP_SIP_REMOTECTL_CFG		0x8200000b
+#define ROCKCHIP_SUSPEND_MODE_CONFIG		0x01
+#define ROCKCHIP_WKUP_SOURCE_CONFIG		0x02
+#define ROCKCHIP_PWM_REGULATOR_CONFIG		0x03
+#define ROCKCHIP_GPIO_POWER_CONFIG		0x04
+#define ROCKCHIP_SUSPEND_DEBUG_ENABLE		0x05
+#define ROCKCHIP_APIOS_SUSPEND_CONFIG		0x06
+#define	ROCKCHIP_REMOTECTL_SET_IRQ		0xf0
+#define ROCKCHIP_REMOTECTL_SET_PWM_CH		0xf1
+#define ROCKCHIP_REMOTECTL_SET_PWRKEY		0xf2
+#define REMOTECTL_GET_WAKEUP_STATE		0xf3
+#define ROCKCHIP_REMOTECTL_ENABLE		0xf4
+
+#define ROCKCHIP_VIRTUAL_POWEROFF		0x07
+
 /* Share mem page types */
 typedef enum {
     SHARE_PAGE_TYPE_INVALID = 0,
