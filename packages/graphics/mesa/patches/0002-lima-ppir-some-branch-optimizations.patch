From e242932d583168f52bcf8cefe64b736b1061a429 Mon Sep 17 00:00:00 2001
From: Erico Nunes <nunes.erico@gmail.com>
Date: Tue, 26 Apr 2022 11:09:24 +0200
Subject: [PATCH] lima/ppir: optimize branch comparison when possible

The branch operation supports comparisons, so it may be possible to
merge a previous comparison operation with the branch operation.
There are several restrictions to do it at this stage, but it may save
instructions in many cases.

Signed-off-by: Erico Nunes <nunes.erico@gmail.com>
---
 src/gallium/drivers/lima/ir/pp/lower.c | 94 ++++++++++++++++++++++++--
 1 file changed, 89 insertions(+), 5 deletions(-)

diff --git a/src/gallium/drivers/lima/ir/pp/lower.c b/src/gallium/drivers/lima/ir/pp/lower.c
index deed1c7f2c9..def1db9cda1 100644
--- a/src/gallium/drivers/lima/ir/pp/lower.c
+++ b/src/gallium/drivers/lima/ir/pp/lower.c
@@ -322,6 +322,89 @@ static bool ppir_lower_sat(ppir_block *block, ppir_node *node)
    return true;
 }
 
+static bool ppir_lower_branch_merge_condition(ppir_block *block, ppir_node *node)
+{
+   /* Check if we can merge a condition with a branch instruction,
+    * removing the need for a select instruction */
+   assert(node->type == ppir_node_type_branch);
+
+   if (!ppir_node_has_single_pred(node))
+      return false;
+
+   ppir_node *pred = ppir_node_first_pred(node);
+   assert(pred);
+
+   if (pred->type != ppir_node_type_alu)
+      return false;
+
+   /* relies on enum order */
+   if (pred->op < ppir_op_lt || pred->op > ppir_op_ne)
+      return false;
+
+   ppir_dest *dest = ppir_node_get_dest(pred);
+   if (!ppir_node_has_single_succ(pred) || dest->type != ppir_target_ssa)
+      return false;
+
+   ppir_alu_node *cond = ppir_node_to_alu(pred);
+   /* branch can't reference pipeline registers */
+   if (cond->src[0].type == ppir_target_pipeline ||
+       cond->src[1].type == ppir_target_pipeline)
+      return false;
+
+   /* branch can't use flags */
+   if (cond->src[0].negate || cond->src[0].absolute ||
+       cond->src[1].negate || cond->src[1].absolute)
+      return false;
+
+   /* at this point, it can be successfully be replaced. */
+   ppir_branch_node *branch = ppir_node_to_branch(node);
+   switch (pred->op)
+   {
+      case ppir_op_le:
+         branch->cond_gt = true;
+         break;
+      case ppir_op_lt:
+         branch->cond_eq = true;
+         branch->cond_gt = true;
+         break;
+      case ppir_op_ge:
+         branch->cond_lt = true;
+         break;
+      case ppir_op_gt:
+         branch->cond_eq = true;
+         branch->cond_lt = true;
+         break;
+      case ppir_op_eq:
+         branch->cond_lt = true;
+         branch->cond_gt = true;
+         break;
+      case ppir_op_ne:
+         branch->cond_eq = true;
+         break;
+      default:
+         assert(0);
+         break;
+   }
+
+   assert(cond->num_src == 2);
+
+   branch->num_src = 2;
+   branch->src[0] = cond->src[0];
+   branch->src[1] = cond->src[1];
+
+   /* for all nodes before the condition */
+   ppir_node_foreach_pred_safe(pred, dep) {
+      /* insert the branch node as successor */
+      ppir_node *p = dep->pred;
+      ppir_node_remove_dep(dep);
+      ppir_node_add_dep(node, p, ppir_dep_src);
+   }
+
+   ppir_node_delete(pred);
+
+   return true;
+}
+
 static bool ppir_lower_branch(ppir_block *block, ppir_node *node)
 {
    ppir_branch_node *branch = ppir_node_to_branch(node);
@@ -330,6 +413,12 @@ static bool ppir_lower_branch(ppir_block *block, ppir_node *node)
    if (branch->num_src == 0)
       return true;
 
+   /* Check if we can merge a condition with the branch */
+   if (ppir_lower_branch_merge_condition(block, node))
+      return true;
+
+   /* If the condition cannot be merged, fall back to a
+    * comparison against zero */
    ppir_const_node *zero = ppir_node_create(block, ppir_op_const, -1, 0);
 
    if (!zero)
@@ -342,11 +431,6 @@ static bool ppir_lower_branch(ppir_block *block, ppir_node *node)
    zero->dest.ssa.num_components = 1;
    zero->dest.write_mask = 0x01;
 
-   /* For now we're just comparing branch condition with 0,
-    * in future we should look whether it's possible to move
-    * comparision node into branch itself and use current
-    * way as a fallback for complex conditions.
-    */
    ppir_node_target_assign(&branch->src[1], &zero->node);
 
    if (branch->negate)
-- 
GitLab

From 7481b8213a9e49ad239dc517e58c6d06db982471 Mon Sep 17 00:00:00 2001
From: Erico Nunes <nunes.erico@gmail.com>
Date: Tue, 26 Apr 2022 11:09:47 +0200
Subject: [PATCH] lima/ppir: merge branch nodes in simple cases

In some simple cases, we can merge the branch operation with an existing
instruction and avoid the creation of an empty new instruction just for
the branch node.

Signed-off-by: Erico Nunes <nunes.erico@gmail.com>
---
 src/gallium/drivers/lima/ir/pp/node_to_instr.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/src/gallium/drivers/lima/ir/pp/node_to_instr.c b/src/gallium/drivers/lima/ir/pp/node_to_instr.c
index ff8d735d9a7..ffe8c5af89d 100644
--- a/src/gallium/drivers/lima/ir/pp/node_to_instr.c
+++ b/src/gallium/drivers/lima/ir/pp/node_to_instr.c
@@ -58,6 +58,18 @@ static bool ppir_do_node_to_instr_try_insert(ppir_block *block, ppir_node *node)
       return ppir_instr_insert_node(succ->instr, node);
    }
 
+   if (ppir_node_has_single_succ(node) &&
+      ppir_node_has_single_pred(ppir_node_first_succ(node)) &&
+      (ppir_node_first_succ(node)->type == ppir_node_type_branch)) {
+
+      assert(ppir_node_has_single_succ(node));
+      ppir_node *succ = ppir_node_first_succ(node);
+      assert(succ);
+      assert(succ->instr);
+
+      return ppir_instr_insert_node(succ->instr, node);
+   }
+
    switch (node->type) {
       case ppir_node_type_load:
          break;
-- 
GitLab

